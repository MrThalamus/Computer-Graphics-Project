#include <GL/glut.h>
#include <cmath>
#include <windows.h>
#include <stdlib.h>
#include <vector>
#define MAX_DROPS 700


#include <math.h>

//Scene C
#ifdef _WIN32
#endif
#include <algorithm>
#include <cstdlib>
#include <ctime>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// ----------------------- Global Variables ----------------------- //
//Scenario A----------------------------------
//Mode
float currentMode = 0;
float currentScene=1;

//Car1 Variable
float car_move1A = 0.0f;
float car_angle1A = 0.0f;
float car1_speed = 0.06;

//Car2 Variable
float car_move2A = 0.0f;
float car_angle2A = 0.0f;
float car2_speed = 0.07;

//car3 Variable
float car_move3A = 0.0f;
float car_angle3A = 0.0f;
float car3_speed = 0.06;

//car4 Variable
float car_move4A = 0.0f;
float car_angle4A = 0.0f;
float car4_speed = 0.06;

//boat1 Variabel
float boat_move1A = 0.0f;

//boat3 variable
float boat_move3A = 0.0f;

// Cloud positions
float cloud1X = -16.5f, cloud1Y = 20.0f;
float cloud2X = -8.0f,  cloud2Y = 22.0f;
float cloud3X = 3.0f,   cloud3Y = 20.0f;
float cloud4X = 12.5f,  cloud4Y = 22.0f;

//Rain variable
float dropX[MAX_DROPS];
float dropY[MAX_DROPS];
int totalDrops = 0;
bool raining = false;

//Plane Variable
float planeX = -4.0f;   // X position of plane
float planeY = 0.0f;   // Y position of plane
float plane_speedX = 0.06f;  // X-axis speed
float plane_speedY = 0.01f;  // Y-axis speed
//Scenario B----------------------------------------------
#include <windows.h>  // for MS Windows
#include <GL/glut.h>  // GLUT, include glu.h and gl.h
#include <math.h>
#include <cmath>
#include <vector>
#include <ctime>

//Rain
//#define MAX_DROPS 300
float dropX_B[MAX_DROPS];
float dropY_B[MAX_DROPS];
float dropSpeed_B[MAX_DROPS];
int dropCount_B = 0;

float cloudX1_B = 0, cloudX2_B = 300, cloudX3_B = 600,cloudX4_B = 200;
float cloudSpeed_B = 0.5f; //Speed of cloud
float sunY_B = 500;
float birdX_B = 10, birdY_B = 680, birdWingY_B = -1, birdDirection_B = 1;
int currentMode_B = 0; //0=day mode,1=night mode,2=evening mode
bool isRaining_B = false;  // rain toggle
float ambulanceX_B = 100;
float busX_B = 400;
bool sirenOn_B = false;
float sirenTimer_B = 0;
float carX_B  = 400.0f;  // First car position
float carX2_B = 530.0f;  // Second car position
float carX3_B = 650.0f;  // Third car position
float carX4_B  = 400.0f;  // Fourth car position
float carX5_B = 530.0f;  // fifth  car position
float carX6_B = 650.0f;  // sixth car position

float carSpeed_B  = 2.0f; // Speed for first car
float carSpeed2_B = 2.5f; // Speed for second car
float carSpeed3_B = 2.2f; // Speed for third car
///Scene c
const int WINDOW_WIDTH = 1200;
const int WINDOW_HEIGHT = 900;

// Traffic light states
enum TrafficLight { RED, YELLOW, GREEN };
TrafficLight trafficLight = RED;

// Animation variables
float car1PosX = -20.0f, car1Speed = 0.05f;
float car2PosX = 20.0f,  car2Speed = 0.05f;
float car3PosX = -15.0f, car3Speed = 0.05f;
float car4PosX = 15.0f,  car4Speed = 0.05f;
float car5PosX = -10.0f, car5Speed = 0.03f;
float car6PosX = 10.0f,  car6Speed = 0.03f;
float cloudPosX = 0.0f;
float cloudSpeed = 0.02f;
float sunAngle = 45.0f;
float sunSpeed = 0.1f;
bool nightMode = false;
float trafficTimer = 0.0f;
const float TRAFFIC_INTERVAL = 5.0f;
const float STOP_DISTANCE = 3.0f;

// Car dimensions
const float CAR_LENGTH = 1.6f;
float leftLaneStop  = -2.0f - CAR_LENGTH/2;
float rightLaneStop =  2.0f + CAR_LENGTH/2;

// People variables - simple values, no arrays
float person1X = -15.0f, person1Y = -1.5f, person1Dir = 1.0f, person1Speed = 0.02f, person1LegAngle = 0.0f, person1LegSwing = 1.0f;
float person2X = -8.0f, person2Y = -1.5f, person2Dir = -1.0f, person2Speed = 0.025f, person2LegAngle = 15.0f, person2LegSwing = -1.0f;
float person3X = 5.0f, person3Y = -1.5f, person3Dir = 1.0f, person3Speed = 0.03f, person3LegAngle = -10.0f, person3LegSwing = 1.0f;
float person4X = 12.0f, person4Y = -1.5f, person4Dir = -1.0f, person4Speed = 0.02f, person4LegAngle = 20.0f, person4LegSwing = -1.0f;
float person5X = -2.0f, person5Y = -1.5f, person5Dir = 1.0f, person5Speed = 0.035f, person5LegAngle = 5.0f, person5LegSwing = 1.0f;

// Rain mode
bool rainMode = false;
float rainTimer = 0.0f;



//Scenario D----------------------------------------------

// Bird 1 (original)
float birdX1_D = -35, birdY1_D = 15;
float birdWingY1_D = -1, birdDirection1_D = 1;
// Bird 2 (smaller)
float birdX2_D = -40, birdY2_D = 13;
float birdWingY2_D = -1, birdDirection2_D = 1;
float birdScale2_D = 0.3f;
// Bird 3 (even smaller)
float birdX3_D = -45, birdY3_D = 10;
float birdWingY3_D = -1, birdDirection3_D = 1;
float birdScale3_D = 0.3f;
//Rain
float dropX_D[MAX_DROPS], dropY_D[MAX_DROPS];
int totalDrops_D = 0;
bool raining_D = false;
//Vehicle
float busWheelAngle_D = 0.0f;
float carWheelAngle_D = 0.0f;
float car2WheelAngle_D = 0.0f;
float carPosX_D = -40.0f;
float carPosX_D_Speed = 0.02f;
float car2PosX_D = 40;
float car2BPosX_D = -40;
float speedMultiplier_D = 1.0f;
float busPosX_D =  20.0f;
float cloud_D_1PosX_D =  -10.0f;
float cloud_D_2PosX_D =  95.0f;
float boat1_PosX_D = 8.0f;
float boat1_Speed_D = -0.03f;
float boat2_PosX_D = 0.0f;
float boat2_Speed_D = 0.05f;
bool isNight_D   = false;
bool isEvening_D = false;
bool paused_D = false;

// Mouse click handler
void mouseHandler_D(int button, int state, int, int)
{
    //Scenario A*********************************************************************
    if (state == GLUT_DOWN)    // when mouse button is pressed
    {
        if (button == GLUT_LEFT_BUTTON)
        {
            car1_speed += 0.01f;
            car2_speed += 0.01;
            car3_speed += 0.01;
            car4_speed += 0.01;
            if (car1_speed > 0.2f || car2_speed > 0.2f || car3_speed > 0.2f || car4_speed > 0.2f)
            {
                car1_speed = 0.2f;
                car2_speed = 0.2f;
                car3_speed = 0.2f;
                car4_speed = 0.2f;
            }
        }
        else if (button == GLUT_RIGHT_BUTTON)
        {
            car1_speed -= 0.01f;
            car2_speed -= 0.01;
            car3_speed -= 0.01;
            car4_speed -= 0.01;
            if (car1_speed < 0.0f || car2_speed < 0.0f || car3_speed < 0.0f || car4_speed < 0.0f)
            {
                car1_speed = 0.0f;
                car2_speed = 0.0f;
                car3_speed = 0.0f;
                car4_speed = 0.0f;
            }
        }
    }
    //Scenario B******************************************************************
    if (state == GLUT_DOWN)
    {
        if (button == GLUT_LEFT_BUTTON)
        {
            isRaining_B = true;   // start rain
        }
        else if (button == GLUT_RIGHT_BUTTON)
        {
            isRaining_B = false;  // stop rain
        }
    }

    ///scene c
      if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        // Cycle through traffic light states
        if (trafficLight == GREEN) {
            trafficLight = YELLOW;
        } else if (trafficLight == YELLOW) {
            trafficLight = RED;
        } else {
            trafficLight = GREEN;
        }
        glutPostRedisplay();
    }

    //Scenario D******************************************************************
    if (state != GLUT_DOWN) return;
    if (button == GLUT_RIGHT_BUTTON)
    {
        raining_D = true;  // start rain
    }
    else if (button == GLUT_LEFT_BUTTON)
    {
        raining_D = false;  // stop rain
        totalDrops_D = 0;   // remove all drops
        for (int i = 0; i < MAX_DROPS; i++)
            dropY_D[i] = -30.0f; // move out of screen
        glutPostRedisplay(); // immediately redraw
    }
}

void keyboard_D(unsigned char key, int x, int y)
{
    // mode switch
    if (key == '1')
    {
        currentScene = 1;
        glutSetWindowTitle("UttaraDiabari");
    }
    else if (key == '2')
    {
        currentScene = 2;
        glutSetWindowTitle("Expressway");
    }
    else if (key == '3')
    {
        currentScene = 3;
        glutSetWindowTitle("Novo Theater");
    }
    else if (key == '4')
    {
        currentScene = 4;
        glutSetWindowTitle("Hatirjheel");
    }

    //Scene A*********************************************************
    if (key == 'R' || key == 'r')
    {
        raining = true;  // Start rain
    }
    if (key == 'X' || key == 'x')
    {
        raining = false;        // Stop rain
        totalDrops = 0;         // Remove all existing drops
    }
    if (key == 'm' || key == 'M') currentMode=0;
    if (key == 'd' || key == 'D') currentMode=1;
    if (key == 'e' || key == 'E') currentMode=2;
    if (key == 'n' || key == 'N') currentMode=3;
    //Scene B*********************************************************
    if (key == 'r' || key == 'R')
    {
        isRaining_B = !isRaining_B;  // toggle rain
    }
    if (key == 'd' || key == 'D') currentMode_B = 0;
    else if (key == 'n' || key == 'N') currentMode_B = 1;
    else if (key == 'e' || key == 'E') currentMode_B = 2;
    glutPostRedisplay();
    //Scenario c******************************************************************
    if (key == 'n' || key == 'N')
    {
        nightMode = !nightMode;
    }
    else if (key == 'r' || key == 'R')
    {
        rainMode = !rainMode;
    }
    else if (key == 27) // ESC key
    {
        exit(0);
    }
    //Scene D*********************************************************
    if (key == 'n' || key == 'N')
    {
        isNight_D   = true;
        isEvening_D = false;
        glutPostRedisplay();
    }
    else if (key == 'e' || key == 'E')
    {
        isEvening_D = true;
        isNight_D   = false;
        glutPostRedisplay();
    }
    else if (key == 'd' || key == 'D')
    {
        isNight_D   = false;
        isEvening_D = false;   // default to day
        glutPostRedisplay();
    }
    if (key == 'h' || key == 'H')
    {
        speedMultiplier_D += 0.5f;
    }
    else if (key == 'l' || key == 'L')
    {
        speedMultiplier_D -= 0.2f;
    }
    else if (key == 'p' || key == 'P')
    {
        paused_D = !paused_D;
    }
}
//Scenario A---------------------------------------------------------------------------------------------------------------------------
//Bird Variable
float birdX = -18, birdY = 20, birdWingY = -1, birdDirection = 1;
struct RGB
{
    int red;
    int green;
    int blue;
};

/*//Polygon Helper
void polygon(std::vector<std::pair<float, float>> coord, RGB rgb = {255, 255, 255},
             float Tx = 0, float Ty = 0, float s = 1)
{
    glColor3ub(rgb.red, rgb.green, rgb.blue);
    glBegin(GL_POLYGON);
    for (int i = 0; i < coord.size(); i++)
        glVertex2f(Tx + s * coord[i].first, Ty + s * coord[i].second);
    glEnd();
}
*/
void polygon(std::vector<std::pair<float, float>> coord, RGB rgb = {255, 255, 255},
               float Tx = 0, float Ty = 0, float s = 1)
{
    glColor3ub(rgb.red, rgb.green, rgb.blue);
    glBegin(GL_POLYGON);
    for (auto& c : coord)
        glVertex2f(Tx + s * c.first, Ty + s * c.second);
    glEnd();
}

// Function to draw a semicircle
void drawSemiCircle(float radius, float xc, float yc, float red, float green, float blue)
{
    float pi = 3.1416;
    glColor3f(red, green, blue);
    glBegin(GL_POLYGON);
    glVertex2f(xc, yc); // center for filling
    for (int i = 0; i <= 200; i++)
    {
        float angle = (i * pi) / 200; // 0 → π
        float x = radius * cos(angle);
        float y = radius * sin(angle);
        glVertex2f(x + xc, y + yc);
    }
    glEnd();
}

//Text Writing
void renderText_D(float x, float y, const char* text)
{
    glRasterPos2f(x, y);  // Set the position to start drawing text
    for (const char* c = text; *c != '\0'; c++)
    {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, *c);  // Render each character
    }
}

//Function to draw a semicircle rotate 90 degree clockwise
void drawSemiCircle90(float radius, float xc, float yc, float red, float green, float blue)
{
    float pi = 3.1416;
    float theta = -pi / 2; // 90° clockwise
    glColor3f(red, green, blue);
    glBegin(GL_POLYGON);
    glVertex2f(xc, yc); // center for filling
    for (int i = 0; i <= 200; i++)
    {
        float angle = (i * pi) / 200; // 0 → π
        float x = radius * cos(angle);
        float y = radius * sin(angle);

        // Rotate the point
        float x_rot = x * cos(theta) - y * sin(theta);
        float y_rot = x * sin(theta) + y * cos(theta);

        glVertex2f(x_rot + xc, y_rot + yc);
    }
    glEnd();
}

//Quad drawing function
void drawQuad(float x1, float y1,
              float x2, float y2,
              float x3, float y3,
              float x4, float y4,
              float r, float g, float b)
{
    glColor3f(r, g, b);
    glBegin(GL_QUADS);
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);
    glVertex2f(x3, y3);
    glVertex2f(x4, y4);
    glEnd();
}

//Function to draw a Triangle
void drawTriangle(float x1, float y1,
                  float x2, float y2,
                  float x3, float y3,
                  float r, float g, float b)
{
    glColor3f(r, g, b);   // Set color
    glBegin(GL_TRIANGLES);
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);
    glVertex2f(x3, y3);
    glEnd();
}
//drawCircle for Cloud
void drawCircle(float cx, float cy, float r)
{
    glBegin(GL_TRIANGLE_FAN);
    for (int i = 0; i <= 100; ++i)
    {
        float theta = 2.0f * 3.1416f * i / 100;
        float x = r * cos(theta);
        float y = r * sin(theta);
        glVertex2f(cx + x, cy + y);
    }
    glEnd();
}

//Circle Drawing Function
void circle(float radius, float xc, float yc, float r, float g, float b)
{
    glBegin(GL_POLYGON);
    for (int i = 0; i < 200; i++)
    {
        glColor3f(r, g, b);
        float pi = 3.1416;
        float A = (i * 2 * pi) / 200;
        float x = radius * cos(A);
        float y = radius * sin(A);
        glVertex2f(x + xc, y + yc);
    }
    glEnd();
}

//Boarder Drawing Function
void drawBorder(float x1, float y1,
                float x2, float y2,
                float x3, float y3,
                float x4, float y4,
                float r, float g, float b)
{
    glColor3f(r,g,b);
    glLineWidth(1.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);
    glVertex2f(x3, y3);
    glVertex2f(x4, y4);
    glEnd();
}

//WheelWithSpoke Drawing Function
void wheelWithSpokes(float xc, float yc, float r1, float r2)
{
    circle(r1, xc, yc, 0, 0, 0);   // outer black tire

    // Draw only the outline of the hub
    glColor3f(1, 1, 1);
    glLineWidth(1.5);
    glBegin(GL_LINE_LOOP);
    for (int i = 0; i < 200; i++)
    {
        float angle = (2 * M_PI * i) / 200;
        float x = r2 * cos(angle);
        float y = r2 * sin(angle);
        glVertex2f(xc + x, yc + y);
    }
    glEnd();

    // Spokes inside hub
    glLineWidth(1.5);
    glColor3f(0, 0, 0);
    glBegin(GL_LINES);
    for (int i = 0; i < 8; i++)
    {
        float angle = i * (M_PI / 4);
        float x = r2 * cos(angle);   // end at inner radius
        float y = r2 * sin(angle);
        glVertex2f(xc, yc);
        glVertex2f(xc + x, yc + y);
    }
    glEnd();
}


// Draw the lake
void drawLakeA()
{
    drawQuad(-18, 6, -18, 1.5, 18, 1.5, 18, 6,0.53f, 0.81f, 0.92f);
}

//Draw all grasses
void grassA()
{
    drawQuad(-18, 7,-18, 6,18, 6,18, 7,0.20f, 0.80f, 0.20f);
    drawQuad(-18, 1.5,-18,0,18,0,18,1.5,0.20f, 0.80f, 0.20f);
    drawQuad(-18,12,-18,9,18,9,18,12,0.20f, 0.80f, 0.20f);
    //drawQuad(1,12,1,9,18,9,18,12,0.20f, 0.80f, 0.20f);
    drawQuad(-18,11,-18,9,18,9,18,11,0.486f, 0.435f, 0.420f);
    //drawQuad(1,11,1,9,18,9,18,11,0.486f, 0.435f, 0.420f);
}

void RoadA()
{
    drawQuad(-18, 9,-18, 7,18, 7,18,9,0.2745f, 0.2784f, 0.2745f);
    //drawQuad(-1, 12,-1, 9,1, 9,1, 12,0.2745f, 0.2784f, 0.2745f);

}

//Sky Drawing
void Sky()
{
    if(currentMode==0)drawQuad(-18,12,18,12,18,25,-18,25,0.98f, 0.84f, 0.65f);
    else if(currentMode==1)drawQuad(-18,12,18,12,18,25,-18,25,0.6,0.9,1.0);
    else if(currentMode==2)drawQuad(-18,12,18,12,18,25,-18,25,0.8,0.5,0.2);
    else if(currentMode==3)drawQuad(-18,12,18,12,18,25,-18,25,0,0,0.1);
    //drawQuad(-18,12,18,12,18,25,-18,25,0.6, 0.9, 1.0);
}

// Draw clouds using the current X positions

void drawCloud(float x, float y)
{
    glColor3f(1.0, 1.0, 1.0);  // white clouds

    // smaller cloud for your coordinate system
    drawCircle(x,       y,       0.6f);
    drawCircle(x + 0.8f, y,       0.6f);
    drawCircle(x + 0.4f, y + 0.5f, 0.6f);
    drawCircle(x + 1.2f, y + 0.3f, 0.5f);
}

void AllCloudA()
{
    drawCloud(cloud1X, cloud1Y);
    drawCloud(cloud2X, cloud2Y);
    drawCloud(cloud3X, cloud3Y);
    drawCloud(cloud4X, cloud4Y);
}


//Car1 Drawing
void wheelCar1A()
{
    glPushMatrix();
    glTranslatef(-13.8, 8, 0);
    glRotatef(car_angle1A, 0.0f, 0.0f, 1.0f);
    glTranslatef(+13.8, -8, 0);
    wheelWithSpokes(-13.8, 8, 0.2, 0.1);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(-12.6, 8, 0);
    glRotatef(car_angle1A, 0.0f, 0.0f, 1.0f);
    glTranslatef(+12.6, -8, 0);
    wheelWithSpokes(-12.6, 8, 0.2, 0.1);
    glPopMatrix();
}

void car1()
{
    glPushMatrix();
    glTranslatef(car_move1A, 0.0f, 0.0f);

    // Car body
    drawQuad(-14.2, 8.6, -14.2, 8, -11.8, 8, -11.8, 8.6, 1, 0, 0);
    drawQuad(-13.8, 9, -14.2, 8.6, -12.4, 8.6, -13, 9, 0, 0, 0);
    drawBorder(-13.8, 9, -14.2, 8.6, -12.4, 8.6, -13, 9,1,0,0);

    // Car window line
    glLineWidth(3.0f);
    glBegin(GL_LINES);
    glColor3f(1, 0, 0);
    glVertex2f(-13.4, 9);
    glVertex2f(-13.4, 8.6);
    glEnd();

    // Wheels
    wheelCar1A();
    if(currentMode==2 || currentMode==3)
        drawTriangle(-11.8,8.4,-10.6, 8.6,-10.6, 8.2,0.8,0.8,0.5);

    glPopMatrix();

    //glutSwapBuffers();
}

//Car2 drawing
void wheelCar2A()
{
    glPushMatrix();
    glTranslatef(10.4, 7.4, 0);
    glRotatef(car_angle2A, 0.0f, 0.0f, 1.0f);
    glTranslatef(-10.4, -7.4, 0);
    wheelWithSpokes(10.4, 7.4, 0.2, 0.1);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(11.8, 7.4, 0);
    glRotatef(car_angle2A, 0.0f, 0.0f, 1.0f);
    glTranslatef(-11.8, -7.4, 0);
    wheelWithSpokes(11.8,7.4, 0.2, 0.1);
    glPopMatrix();
}

void car2WindowA(float tx, float ty)
{
    glPushMatrix();

    // Translate the whole window
    glTranslatef(tx, ty, 0.0f);

    // Draw the window (white rectangle)
    drawQuad(10.6, 8, 10.6, 7.8, 10.8, 7.8, 10.8, 8, 1, 1, 1);

    glPopMatrix();
}

void car2()
{
    glPushMatrix();
    glTranslatef(car_move2A, 0.0f, 0.0f);

    // Car body
    drawQuad(10, 8.2, 10, 7.4, 12.2, 7.4, 12.2, 8.2, 1, 1, 0);
    drawQuad(10.2, 8, 10.2, 7.6, 10.4, 7.6, 10.4, 8, 1, 1, 1);
    car2WindowA(0,0);
    car2WindowA(0.4,0);
    car2WindowA(0.8,0);
    car2WindowA(1.2,0);


    // Wheels
    wheelCar2A();
    if(currentMode==2 || currentMode==3)
        drawTriangle(8.8, 7.8,8.8, 7.4,10,7.6,0.8,0.8,0.5);


    glPopMatrix();

    //glutSwapBuffers();
}

//Car3 drawing
void wheelCar3A()
{
    glPushMatrix();
    glTranslatef(-1, 7.5, 0);
    glRotatef(car_angle3A, 0.0f, 0.0f, 1.0f);
    glTranslatef(1, -7.5, 0);
    wheelWithSpokes(-1, 7.5, 0.2, 0.1);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.5, 7.5, 0);
    glRotatef(car_angle3A, 0.0f, 0.0f, 1.0f);
    glTranslatef(-0.5, -7.5, 0);
    wheelWithSpokes(0.5, 7.5, 0.2,0.1);
    glPopMatrix();
}

void car3()
{
    glPushMatrix();
    glTranslatef(car_move3A, 0.0f, 0.0f);

    // Car body
    drawQuad(-1.5, 8.5, -1.5, 7.5, 1, 7.5, 1, 8.5, 0.55f, 0.27f, 0.07f);
    drawQuad(-1.4, 8.4,-1.4, 7.8,-1.2, 7.8,-1.2, 8.4,1,1,1);
    drawQuad(-1, 8.5,-1, 8,0.5, 8,0.5, 8.5,1,1,1);


    // Wheels
    wheelCar3A();
    if(currentMode==2 || currentMode==3)
        drawTriangle(-2.8, 8,-2.8, 7.6,-1.5, 7.79,0.8,0.8,0.5);

    glPopMatrix();

    //glutSwapBuffers();
}
void wheelCar4A()
{
    glPushMatrix();
    glTranslatef(2, 8.6, 0);
    glRotatef(car_angle4A, 0.0f, 0.0f, 1.0f);
    glTranslatef(-2, -8.6, 0);
    wheelWithSpokes(2, 8.6, 0.2, 0.1);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(3.2, 8.6, 0);
    glRotatef(car_angle4A, 0.0f, 0.0f, 1.0f);
    glTranslatef(-3.2,- 8.6, 0);
    wheelWithSpokes(3.2, 8.6, 0.2,0.1);
    glPopMatrix();
}

void car4()
{

    glPushMatrix();
    glTranslatef(car_move4A, 0.0f, 0.0f);

    // Car body
    drawQuad(1.6, 9.6,1.6, 8.6,3.8, 8.6,3.8, 9.6,1,0,0);
    drawQuad(1.8, 9.6,1.8, 9.4,3.6, 9.4,3.6, 9.6,1,1,1);
    drawQuad(3, 9.4,3,9,3.6,9,3.6, 9.4,0.85f,0.95f,1.0f);
    drawQuad(1.8, 9.4,1.8, 9,2.2, 9,2.2, 9.4,0.85f,0.95f,1.0f);
    drawQuad(3.2, 9.8,3.2, 9.6,3.6, 9.6,3.6, 9.8,0,0,0);
    drawQuad(3.3, 9.9,3.3, 9.8,3.5, 9.8,3.5, 9.9,1,1,0);

    // Wheels
    wheelCar4A();
    if(currentMode==2 || currentMode==3)
    {
        drawTriangle(3.8, 8.8,5,9,5, 8.6,0.8,0.8,0.5);
        circle(0.15,3.4, 9.85,0.8,0.8,0.5);
    }

    glPopMatrix();

}

//ALL car
void AllCarA()
{
    car4();
    car1();
    car3();
    car2();
}

//Boat1 Drawing
void Boat1A()
{
    glPushMatrix();
    glTranslatef(boat_move1A, 0.3, 0.0f);


    drawQuad(9, 6,11, 4.5,14, 4.5,15, 6,0.50f, 0.0f, 0.0f);
    drawBorder(9, 6,11, 4.5,14, 4.5,15, 6,0,0,0);
    drawQuad(12, 6.5,12, 6,14, 6,14, 6.5,0,0,0);

    glPopMatrix();

    //glutSwapBuffers();
}

void sampleBoat(float x, float y, float r, float g, float b)
{
    glPushMatrix();
    glTranslatef(x,y,0);
    drawQuad(12.5, 4,12.5,3.5,14,3.5,14, 4,0,0,0);
    drawQuad(12, 3.5,12, 2.5,15, 2.5,16.5, 3.5,r,g,b);
    drawBorder(12, 3.5,12, 2.5,15, 2.5,16.5, 3.5,0,0,0);
    drawQuad(12.8, 5,12.8,4,13, 4,13,5,0,0,0);
    drawTriangle(13, 5,15,3.5,16,3.5,0,0,0);
    glPopMatrix();

}

void Boat2A()
{
    sampleBoat(0,-0.7,1,0,0);
}

void Boat3A()
{
    glPushMatrix();
    glTranslatef(boat_move3A,0,0);
    sampleBoat(-15,1,0.0f, 0.39f, 0.0f);
    glPopMatrix();

}

//All Boat
void AllBoat()
{
    Boat1A();
    Boat3A();
    Boat2A();
}

//Rain
void addDrop()
{
    if (totalDrops < MAX_DROPS)
    {
        dropX[totalDrops] = -18.0f + static_cast<float>(rand()) / (RAND_MAX / 36.0f); // -18 to 18
        dropY[totalDrops] = 25.0f;  // top of the window
        totalDrops++;
    }
}

void RainUpdate(int value)
{
    if (raining)
    {
        for (int i = 0; i < totalDrops; i++)
        {
            dropY[i] -= 0.2f; // fall speed

            if (dropY[i] <= 0.0f)   // bottom of the scene
            {
                for (int j = i; j < totalDrops - 1; j++)
                {
                    dropX[j] = dropX[j + 1];
                    dropY[j] = dropY[j + 1];
                }
                totalDrops--;
                i--;
            }
        }

        for (int i = 0; i < 5; i++) addDrop();
    }
    glutPostRedisplay();
    glutTimerFunc(16, RainUpdate, 0);
}


void drawRaindropsA()
{
    glColor3f(0.2f, 0.4f, 1.0f);
    glBegin(GL_LINES);
    for (int i = 0; i < totalDrops; i++)
    {
        glVertex2f(dropX[i], dropY[i]);
        glVertex2f(dropX[i], dropY[i] - 0.25f);
    }
    glEnd();
}
//Plane Drawing
void PlaneA()
{
    glPushMatrix();
    glTranslatef(planeX, planeY, 0.0f);  // move plane by translation

    drawQuad(-14.3, 17.4,-14.2, 17,-14, 17,-14.2, 17.4,1,0,0);
    drawQuad(-14.37,16.8,-14, 16.5,-11.6, 16.5,-11.6, 16.8,1,1,1);
    drawSemiCircle90(0.15,-11.599,16.65,1,1,1);
    drawQuad(-14.376,17,-14.376,16.8,-12,16.8,-12, 17,1,1,1);
    drawQuad(-14.5, 17,-14.5, 16.9,-14.376,16.8,-14.376,17,1,1,1);
    drawQuad(-11.9,16.95,-12.1,16.95,-12.1, 16.8,-11.6, 16.8,1,1,1);
    drawQuad(-12,16.95,-12,16.8,-11.6, 16.8,-11.9,16.95,0,0,0);
    drawQuad(-13.6, 17.2,-13.2, 16.8,-12.8, 16.8,-13.4, 17.2,1,0,0);
    drawQuad(-13.8, 16.9,-13.8, 16.8,-13.7, 16.8,-13.7, 16.9,0,0,0);
    drawQuad(-13.5, 16.9,-13.5, 16.8,-13.4, 16.8,-13.4, 16.9,0,0,0);
    drawQuad(-12.7, 16.9,-12.7, 16.8,-12.6, 16.8,-12.6, 16.9,0,0,0);
    drawQuad(-12.4, 16.9,-12.4, 16.8,-12.3, 16.8,-12.3, 16.9,0,0,0);

    glPopMatrix();
}

//Building Drawing
void BuildingWindow1A(float tx, float ty)
{
    glPushMatrix();
    glTranslatef(tx, ty, 0.0f);

    drawQuad(-14.8, 14.8, -14.8, 14.4, -14.4, 14.4, -14.4, 14.8, 1, 1, 1);
    drawBorder(-14.8, 14.8, -14.8, 14.4, -14.4, 14.4, -14.4, 14.8, 0, 0, 0);

    glPopMatrix();
}

void BuildingWindow2A(float tx, float ty)
{
    glPushMatrix();
    glTranslatef(tx, ty, 0.0f);

    drawQuad(14.5, 16.5, 14.5, 16, 17,16, 17, 16.5, 1, 1, 1);
    drawBorder(14.5, 16.5, 14.5, 16, 17,16, 17, 16.5, 0, 0, 0);

    glPopMatrix();
}

void Building1A(float tx, float ty)
{

    glPushMatrix();
    glTranslatef(tx, ty, 0.0f);
    drawQuad(-15, 15,-15, 11,-12, 11,-12, 15,0.647f, 0.165f, 0.165f);
    BuildingWindow1A(0,0);
    BuildingWindow1A(1.1,0);
    BuildingWindow1A(2.2,0);
    BuildingWindow1A(0,-1);
    BuildingWindow1A(1.1,-1);
    BuildingWindow1A(2.2,-1);
    BuildingWindow1A(0,-2);
    BuildingWindow1A(1.1,-2);
    BuildingWindow1A(2.2,-2);
    BuildingWindow1A(0,-3);
    BuildingWindow1A(2.2,-3);
    drawQuad(-13.8, 11.8,-13.8,11,-13.2,11,-13.2, 11.8,1,1,1);
    drawBorder(-13.8, 11.8,-13.8,11,-13.2,11,-13.2, 11.8,0,0,0);
    drawQuad(-15, 15.5,-15, 15,-12, 15,-12, 15.5,0,0,0);
    glPopMatrix();
}

void Building2A()
{
    drawQuad(14, 17.5,14, 11,17.5, 11,17.5, 17.5,1.0f, 1.0f, 0.6f);
    drawBorder(14, 17.5,14, 11,17.5, 11,17.5, 17.5,0,0,0);
    BuildingWindow2A(0,0);
    BuildingWindow2A(0,-1);
    BuildingWindow2A(0,-2);
    BuildingWindow2A(0,-3);
    drawQuad(15, 12.5,15,11,16.5,11,16.5,12.5,1,1,1);
    drawBorder(15, 12.5,15,11,16.5,11,16.5,12.5,0,0,0);
    drawQuad(14, 18,14, 17.5,17.5, 17.5,17.5, 18,0,0,0);
    glColor3f(0.0f, 0.0f, 0.0f);
    renderText_D(15, 16.8, "School");

}

void Building3A()
{
    drawQuad(-17, 18,-17, 11,-14, 11,-14, 18,1,1,1);
    drawBorder(-17, 18,-17, 11,-14, 11,-14, 18,1,0,0);
    drawQuad(-16.5, 17,-16.5, 12.5,-15.5, 12.5,-15.5, 17,0.85f,0.95f,1.0f);
    drawBorder(-16.5, 17,-16.5, 12.5,-15.5, 12.5,-15.5, 17,0,0,0);
    drawQuad(-15.5, 17,-15.5, 12.5,-14.5, 12.5,-14.5, 17,0.85f,0.95f,1.0f);
    drawBorder(-15.5, 17,-15.5, 12.5,-14.5, 12.5,-14.5, 17,0,0,0);
    drawQuad(-15.8, 12,-15.8,11,-15.2,11,-15.2, 12,0.85f,0.95f,1.0f);
    drawBorder(-15.8, 12,-15.8,11,-15.2,11,-15.2, 12,0,0,0);
    glColor3f(1.0f, 0.0f, 0.0f);
    renderText_D(-16.3, 17.3, "Hospital");
}

void Building4A()
{
    drawQuad(-3, 17,-3, 11,3, 11,3, 17,0.502f, 0.600f, 0.800f);
    drawBorder(-3, 17,-3, 11,3, 11,3, 17,0,0,0);
    drawQuad(-2, 15.5,-2, 12.5,2, 12.5,2, 15.5,0.85f,0.95f,1.0f);
    drawBorder(-2, 15.5,-2, 12.5,2, 12.5,2, 15.5,0,0,0);
    drawQuad(-3, 17.5,-3,17,3,17,3,17.5,0,0,0);
    drawBorder(-3, 17.5,-3,17,3,17,3,17.5,0,0,0);
    drawQuad(-1.5,12,-1.5,11,1.5,11,1.5,12,0.85f,0.95f,1.0f);
    drawBorder(-1.5,12,-1.5,11,1.5,11,1.5,12,0,0,0);
    glLineWidth(1);
    glColor3f(0,0,0);
    glBegin(GL_LINES);
    glVertex2f(-1,15.5);
    glVertex2f(-1,12.5);
    glEnd();
    glBegin(GL_LINES);
    glVertex2f(0,15.5);
    glVertex2f(0,12.5);
    glEnd();
    glBegin(GL_LINES);
    glVertex2f(1,15.5);
    glVertex2f(1,12.5);
    glEnd();
    glBegin(GL_LINES);
    glVertex2f(-2,14.5);
    glVertex2f(2,14.5);
    glEnd();
    glBegin(GL_LINES);
    glVertex2f(-2,13.5);
    glVertex2f(2,13.5);
    glEnd();
    glColor3f(0.0f, 0.0f, 0.0f);
    renderText_D(-1.5, 16.1, "Shopping Mall");



}

void AllBuildingA()
{
    Building1A(1.5,0);//Building 1
    Building1A(5,0);
    Building1A(8.5,0);
    Building1A(18.5,0);
    Building1A(22,0);
    Building1A(25.5,0);
    Building2A();
    Building3A();
    Building4A();
}

//Tree Drawing
void TreeA(float tx, float ty)
{
    glPushMatrix();
    glTranslatef(tx, ty, 0.0f);
    drawQuad(-14.6,10.5,-14.6,9,-14.4,9,-14.4,10.5,0.545f, 0.270f, 0.074f);
    circle(0.3,-14.7,10.5,0.196f, 0.803f, 0.196f);
    circle(0.3,-14.3,10.5,0.196f, 0.803f, 0.196f);
    circle(0.34,-14.5, 10.7,0.196f, 0.803f, 0.196f);
    glPopMatrix();
}

void AllTreeA()
{
    TreeA(-3,0);
    TreeA(0,0);
    TreeA(3,0);
    TreeA(6,0);
    TreeA(9,0);
    TreeA(12,0);

    TreeA(17,0);
    TreeA(20,0);
    TreeA(23,0);
    TreeA(26,0);
    TreeA(29,0);
    TreeA(32,0);

}

//Street Light Drawing
void drawSemiCircleArc(float xc, float yc, float radius, float r, float g, float b,
                       float startAngle = 0.0f, float sweepAngle = 180.0f)
{
    glColor3f(r, g, b);
    glLineWidth(3.0f);  // line width
    glBegin(GL_LINE_STRIP);  // outline
    int segments = 100;      // smoothness

    for (int i = 0; i <= segments; i++)
    {
        float angle = startAngle + (sweepAngle * i / segments);
        float rad = angle * 3.1415926f / 180.0f;  // convert to radians
        float x = xc + radius * cos(rad);
        float y = yc + radius * sin(rad);
        glVertex2f(x, y);
    }

    glEnd();
}

void StreeLight(float tx, float ty, float r, float g, float b)
{
    glPushMatrix();
    glTranslatef(tx, ty, 0.0f);
    drawQuad(-13.05, 10.7,-13.05, 9,-12.95, 9,-12.95, 10.7,0,0,0);
    drawSemiCircleArc(-13,10.4,0.36,0,0,0);
    circle(0.12,-13.35,10.3,r,g,b);
    circle(0.12,-12.65,10.3,r,g,b);
    glPopMatrix();

}

void AllStreetLight()
{
    if(currentMode==0 || currentMode==1)
    {
        StreeLight(0,0,1,1,1);
        StreeLight(-3,0,1,1,1);
        StreeLight(3,0,1,1,1);
        StreeLight(6,0,1,1,1);
        StreeLight(9,0,1,1,1);
        StreeLight(12,0,1,1,1);
        StreeLight(17,0,1,1,1);
        StreeLight(20,0,1,1,1);
        StreeLight(23,0,1,1,1);
        StreeLight(26,0,1,1,1);
        StreeLight(29,0,1,1,1);

        StreeLight(0,-2,1,1,1);
        StreeLight(-3,-2,1,1,1);
        StreeLight(3,-2,1,1,1);
        StreeLight(6,-2,1,1,1);
        StreeLight(9,-2,1,1,1);
        StreeLight(12,-2,1,1,1);
        StreeLight(17,-2,1,1,1);
        StreeLight(20,-2,1,1,1);
        StreeLight(23,-2,1,1,1);
        StreeLight(26,-2,1,1,1);
        StreeLight(29,-2,1,1,1);
    }
    else if(currentMode==3 || currentMode==2)
    {
        StreeLight(0,0,1,1,0);
        StreeLight(-3,0,1,1,0);
        StreeLight(3,0,1,1,0);
        StreeLight(6,0,1,1,0);
        StreeLight(9,0,1,1,0);
        StreeLight(12,0,1,1,0);
        StreeLight(17,0,1,1,0);
        StreeLight(20,0,1,1,0);
        StreeLight(23,0,1,1,0);
        StreeLight(26,0,1,1,0);
        StreeLight(29,0,1,1,0);

        StreeLight(0,-2,1,1,0);
        StreeLight(-3,-2,1,1,0);
        StreeLight(3,-2,1,1,0);
        StreeLight(6,-2,1,1,0);
        StreeLight(9,-2,1,1,0);
        StreeLight(12,-2,1,1,0);
        StreeLight(17,-2,1,1,0);
        StreeLight(20,-2,1,1,0);
        StreeLight(23,-2,1,1,0);
        StreeLight(26,-2,1,1,0);
        StreeLight(29,-2,1,1,0);
    }
}

//Road Strips
void RoadStrip(float tx, float ty)
{
    glPushMatrix();
    glTranslatef(tx, ty, 0.0f);
    drawQuad(-13.6, 8.1,-13.6, 7.9,-12, 7.9,-12, 8.1,1,1,1);
    glPopMatrix();
}

void AllRoadStrip()
{
    RoadStrip(-3,0);
    RoadStrip(0,0);
    RoadStrip(3,0);
    RoadStrip(6,0);
    RoadStrip(9,0);
    RoadStrip(12,0);
    RoadStrip(15,0);
    RoadStrip(18,0);
    RoadStrip(21,0);
    RoadStrip(24,0);
    RoadStrip(27,0);
    RoadStrip(30,0);
}

//Bird Drawing
void bird(float Tx, float Ty, float direction, float birdWingY,
          RGB rgb = {0,0,0}, float s = 1)
{
    // scale body coordinates to fit gluOrtho2D
    float scaleFix = 0.05f * s;

    // body
    polygon(
    {
        {28.65f * direction, 2.99f},
        {31.98f * direction, 1.74f},
        {31.6f * direction, 0.23f},
        {31.93f * direction, -1.29f},
        {30.43f * direction, -0.38f},
        {28.77f * direction, -1.12f},
        {24.29f * direction, -4.59f},
        {16.47f * direction, -5.28f},
        {10.7f * direction, -4.96f},
        {2.95f * direction, -10.29f},
        {8.55f * direction, -3.22f},
        {0.18f * direction, 1.29f},
        {9.57f * direction, -0.31f},
        {11.02f * direction, 0.27f},
        {22.82f * direction, 1.86f},
        {28.65f * direction, 2.99f}
    }, rgb, Tx, Ty, scaleFix);

    // wing
    polygon(
    {
        {22.82f * direction, birdWingY * 1.86f},
        {23.38f * direction, birdWingY * 8.57f},
        {9.98f * direction, birdWingY * 25.45f},
        {11.02f * direction, birdWingY * 0.27f}
    }, rgb, Tx, Ty, scaleFix);
}

void birdAnimation()
{
    birdX += 0.05f;   // move right
    birdWingY += 0.1f;  // wing flapping
    if (birdWingY > 1) birdWingY = -1;

    // Reset bird when it goes off screen
    if (birdX > 21) birdX = -19;
}

void ControlBirds()
{
    if (currentMode == 0 || currentMode == 1 || currentMode == 2)   // day or evening
    {
        bird(birdX-3, birdY, birdDirection, birdWingY, {0,0,0},0.5);
        bird(birdX, birdY-1, birdDirection, -birdWingY, {0,0,0},0.5);
        bird(birdX+3, birdY-2, birdDirection, birdWingY, {0,0,0},0.5);
    }
}

//Draw Sun
void Sun(float x, float y, float r, float g, float b)
{
    glPushMatrix();
    glTranslated(x, y, 0.0);

    // Draw the sun core (circle) with fixed radius 1.5
    circle(1.5, 0, 0, r, g, b);  // center at (0,0) because we translated

    // Draw rays
    glColor3f(r, g, b);  // same as sun color
    glLineWidth(2);
    glBegin(GL_LINES);
    int rays = 16;  // number of rays
    float pi = 3.1416f;
    float rayStart = 1.5 + 0.2f;  // start just outside the sun
    float rayEnd = 1.5 + 0.7f;    // length of the ray
    for (int i = 0; i < rays; i++)
    {
        float A = (2 * pi * i) / rays;  // evenly spaced angles
        float x1 = rayStart * cos(A);   // start of ray
        float y1 = rayStart * sin(A);
        float x2 = rayEnd * cos(A);     // end of ray
        float y2 = rayEnd * sin(A);
        glVertex2f(x1, y1);
        glVertex2f(x2, y2);
    }
    glEnd();

    glPopMatrix();
}
void AllSun()
{
    if(currentMode==0)Sun(-12.5,20.5,1,0.5,0);
    else if(currentMode==1)Sun(0.5,22.5,1.0f, 0.843f, 0.0f);
    else if (currentMode==2)Sun(13,20.5,1,0.2,0);
}
//Draw Moon
void drawMoon()
{
    if (currentMode == 3)
    {
        glColor3f(0.9, 0.9, 0.8);
        drawCircle(4, 22, 1.002);
        // Add some craters
        glColor3f(0.7, 0.7, 0.6);
        drawCircle(3.6, 22.4, 0.1);
        drawCircle(4.2, 22.6, 0.1);
        drawCircle(4.6, 22,0.17);
        drawCircle(4, 21.4,0.23);
    }
}
//Traffic Light
void TrafficLight()
{
    glPushMatrix();
    glTranslatef(0.5,0, 0.0f);
    drawQuad(-0.1, 10.8,-0.1, 9.8,0.3, 9.8,0.3, 10.8,0,0,0);
    drawQuad(0.05,9.8,0.05,9,0.15,9,0.15,9.8,0,0,0);
    circle(0.1,0.1,10.6,1,0,0);
    circle(0.1,0.1,10.3,1,1,0);
    circle(0.1,0.1,10.0,0,1,0);
    glPopMatrix();
}

//LakeSide Boundary
void boundary_grill(float x, float y)
{
    glPushMatrix();
    glTranslatef(x,y,0);
    glColor3f(0,0,0);
    glLineWidth(2);
    glBegin(GL_LINES);
    glVertex2f(-17.5,6.5);
    glVertex2f(-17.5,6.0);
    glEnd();
    glPopMatrix();

}
void Boundary(float x, float y)
{
    glPushMatrix();
    glTranslatef(x,y,0);
    glColor3f(0,0,0);
    glLineWidth(3.5);
    glBegin(GL_LINES);
    glVertex2f(-18,6.5);
    glVertex2f(18,6.5);
    glEnd();
    boundary_grill(0,0);
    boundary_grill(0.5,0);
    boundary_grill(1,0);
    boundary_grill(1.5,0);
    boundary_grill(2,0);
    boundary_grill(2.5,0);
    boundary_grill(3,0);
    boundary_grill(3.5,0);
    boundary_grill(4,0);
    boundary_grill(4.5,0);
    boundary_grill(5,0);
    boundary_grill(5.5,0);
    boundary_grill(6,0);
    boundary_grill(6.5,0);
    boundary_grill(7,0);
    boundary_grill(7.5,0);
    boundary_grill(8,0);
    boundary_grill(8.5,0);
    boundary_grill(9,0);
    boundary_grill(9.5,0);
    boundary_grill(10,0);
    boundary_grill(10.5,0);
    boundary_grill(11,0);
    boundary_grill(11.5,0);
    boundary_grill(12,0);
    boundary_grill(12.5,0);
    boundary_grill(13,0);
    boundary_grill(13.5,0);
    boundary_grill(14,0);
    boundary_grill(14.5,0);
    boundary_grill(15,0);
    boundary_grill(15.5,0);
    boundary_grill(16,0);
    boundary_grill(16.5,0);
    boundary_grill(17,0);
    boundary_grill(17.5,0);
    boundary_grill(18,0);
    boundary_grill(18.5,0);
    boundary_grill(19,0);
    boundary_grill(19.5,0);
    boundary_grill(20,0);
    boundary_grill(20.5,0);
    boundary_grill(21,0);
    boundary_grill(21.5,0);
    boundary_grill(22,0);
    boundary_grill(22.5,0);
    boundary_grill(23,0);
    boundary_grill(23.5,0);
    boundary_grill(24,0);
    boundary_grill(24.5,0);
    boundary_grill(25,0);
    boundary_grill(25.5,0);
    boundary_grill(26,0);
    boundary_grill(26.5,0);
    boundary_grill(27,0);
    boundary_grill(27.5,0);
    boundary_grill(28,0);
    boundary_grill(28.5,0);
    boundary_grill(29,0);
    boundary_grill(29.5,0);
    boundary_grill(30,0);
    boundary_grill(30.5,0);
    boundary_grill(31,0);
    boundary_grill(31.5,0);
    boundary_grill(32,0);
    boundary_grill(32.5,0);
    boundary_grill(33,0);
    boundary_grill(33.5,0);
    boundary_grill(34,0);
    boundary_grill(34.5,0);
    boundary_grill(35,0);
    boundary_grill(35.5,0);
    glPopMatrix();

}
void Boundary1()
{
    Boundary(0,0);
}
void Boundary2()
{
    Boundary(0,-4.5);
}
//Star
void Star(float x, float y)
{
    glPushMatrix();
    glTranslatef(x,y,0);
    circle(0.08,-16, 22,0.7f, 0.8f, 1.0f);
    circle(0.08,-12, 24,0.7f, 0.8f, 1.0f);
    circle(0.08,-8, 23,0.7f, 0.8f, 1.0f);
    circle(0.08,-5, 24.5,0.7f, 0.8f, 1.0f);
    circle(0.08,-2, 23,0.7f, 0.8f, 1.0f);
    circle(0.08,3, 24,0.7f, 0.8f, 1.0f);
    circle(0.08,5.5, 24.5,0.7f, 0.8f, 1.0f);
    circle(0.08,7.5, 24.5,0.7f, 0.8f, 1.0f);
    circle(0.08,13, 24,0.7f, 0.8f, 1.0f);
    circle(0.08,16, 23,0.7f, 0.8f, 1.0f);
    circle(0.08,17, 25,0.7f, 0.8f, 1.0f);
    glPopMatrix();

}

void AllStar()
{
    if(currentMode==3)
    {
        Star(0,0);
        Star(1,-2);
        Star(-1,-4);
        Star(0,-6);
        Star(2,-8);
    }
}

// Draw the full scene
void UttaraDiaBari()
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-18,18,0,25);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    drawLakeA();
    grassA();
    RoadA();
    AllRoadStrip();
    Sky();
    AllStar();
    AllSun();
    drawMoon();
    PlaneA();
    AllCloudA();
    ControlBirds();
    AllBuildingA();
    AllTreeA();
    TrafficLight();
    AllCarA();
    Boundary1();
    AllBoat();
    Boundary2();
    AllStreetLight();
    drawRaindropsA();

}

//Cloud Update Function
void CloudMovement(int value)
{
    cloud1X += 0.02f;
    cloud2X += 0.02f;
    cloud3X += 0.02f;
    cloud4X += 0.02f;

    // Wrap clouds back into view when they leave the screen
    if (cloud1X > 18.5) cloud1X = -19;
    if (cloud2X > 18.5) cloud2X = -19;
    if (cloud3X > 18.5) cloud3X = -19;
    if (cloud4X > 18.5) cloud4X = -19;

    glutPostRedisplay();
    glutTimerFunc(16, CloudMovement, 0); // ~60 FPS
}

//Car1 Update Function

void car_update1A(int value)
{
    car_move1A += car1_speed; // car speed
    if (car_move1A > 32.4)     // full road length (-18 to +18 = 36)
    {
        car_move1A = -4.5;    // reset from left side
    }
    glutPostRedisplay();
    glutTimerFunc(16, car_update1A, 0);
}

void car_rotate1A(int value)
{
    car_angle1A -= 6.0f;
    if (car_angle1A < -360.0f)
        car_angle1A += 360.0f;
    glutPostRedisplay();
    glutTimerFunc(16, car_rotate1A, 0);
}

//car2 update function
void car_update2A(int value)
{
    car_move2A -= car2_speed; // car moves left
    if (car_move2A < -30.5)     // passed left boundary
    {
        car_move2A = 7.8;      // reset from right
    }
    glutPostRedisplay();
    glutTimerFunc(16, car_update2A, 0);
}

void car_rotate2A(int value)
{
    car_angle2A += 6.0f;   // rotate anti-clockwise
    if (car_angle2A > 360.0f)
        car_angle2A -= 360.0f;
    glutPostRedisplay();
    glutTimerFunc(16, car_rotate2A, 0);
}

//car3 update function
void car_update3A(int value)
{
    car_move3A -= car3_speed; // car moves left
    if (car_move3A < -19.5)     // passed left boundary
    {
        car_move3A = 19;      // reset from right
    }
    glutPostRedisplay();
    glutTimerFunc(16, car_update3A, 0);
}

void car_rotate3A(int value)
{
    car_angle3A += 6.0f;   // rotate anti-clockwise
    if (car_angle3A > 360.0f)
        car_angle3A -= 360.0f;
    glutPostRedisplay();
    glutTimerFunc(16, car_rotate3A, 0);
}

//car4 update function
void car_update4A(int value)
{
    car_move4A += car4_speed; // car speed
    if (car_move4A > 17.5)     // full road length (-18 to +18 = 36)
    {
        car_move4A = -22;    // reset from left side
    }
    glutPostRedisplay();
    glutTimerFunc(16, car_update4A, 0);
}

void car_rotate4A(int value)
{
    car_angle1A -= 6.0f;
    if (car_angle4A < -360.0f)
        car_angle4A += 360.0f;
    glutPostRedisplay();
    glutTimerFunc(16, car_rotate4A, 0);
}

//Boat1 upadte Function
void boat_update1A(int value)
{
    boat_move1A -= 0.02f; // car moves left
    if (boat_move1A < -35)     // passed left boundary
    {
        boat_move1A = 8;      // reset from right
    }
    glutPostRedisplay();
    glutTimerFunc(16, boat_update1A, 0);
}

//Boat3 update Function
void boat_update3A(int value)
{
    boat_move3A += 0.02f; // car moves left
    if (boat_move3A > 22)     // passed left boundary
    {
        boat_move3A = -17;      // reset from right
    }
    glutPostRedisplay();
    glutTimerFunc(16, boat_update3A, 0);
}

//Plane Update Function
void plane_update(int value)
{
    planeX += plane_speedX;
    planeY += plane_speedY;

    // Reset if plane goes out of boundary
    if (planeX > 36) planeX = -4;
    if (planeY > 6.6) planeY = 0;

    glutPostRedisplay();
    glutTimerFunc(16, plane_update, 0);  // call again after 16 ms (~60 FPS)
}

//
void Bird_update(int value)
{
    birdAnimation();
    glutPostRedisplay();
    glutTimerFunc(16, Bird_update, 0);
}

//Scenario B---------------------------------------------------------------------------------------------------------------------------
//function to draw circle
void drawCircle_B(float cx, float cy, float r)
{
    glBegin(GL_TRIANGLE_FAN);
    for (int i = 0; i <= 100; ++i)
    {
        float theta = 2.0f * 3.1416f * i / 100;
        float x = r * cos(theta);
        float y = r * sin(theta);
        glVertex2f(cx + x, cy + y);
    }
    glEnd();
}

// Function to render text at a specified position with font
void renderText_B(float x, float y, void* font, const char* text)
{
    glRasterPos2f(x, y);  // Set text start position
    for (const char* c = text; *c != '\0'; c++)
    {
        glutBitmapCharacter(font, *c);
    }
}

//Rain
/*#define MAX_DROPS 200
float dropX_B[MAX_DROPS];
float dropY_B[MAX_DROPS];
float dropSpeed_B[MAX_DROPS];
int dropCount_B = 0;*/

struct Bubble_B
{
    float x, y;      // position
    float radius;    // growing radius
    bool active;     // is bubble visible
};

//for bird
struct RGB_B
{
    int red;
    int green;
    int blue;
};

// helper function to draw polygon(bird)
/*void polygon_B(std::vector<std::pair<float, float>> coord, RGB_B rgb_B = {255, 255, 255},
               float Tx_B = 0, float Ty_B = 0, float s_B = 1)
{
    glColor3ub(rgb_B.red, rgb_B.green, rgb_B.blue);
    glBegin(GL_POLYGON);
    for (int i = 0; i < coord.size(); i++)
        glVertex2f(Tx_B + s_B * coord[i].first, Ty_B + s_B * coord[i].second);
    glEnd();
}*/

void polygon_B(std::vector<std::pair<float, float>> coord, RGB_B rgb = {255, 255, 255},
               float Tx = 0, float Ty = 0, float s = 1)
{
    glColor3ub(rgb.red, rgb.green, rgb.blue);
    glBegin(GL_POLYGON);
    for (auto& c : coord)
        glVertex2f(Tx + s * c.first, Ty + s * c.second);
    glEnd();
}
// draw one bird
void bird_B(float Tx_B, float Ty_B, float direction_B, float birdWingY_B, RGB_B rgb_B = {0,0,0}, float s_B = 1)
{
    // body
    polygon_B(
    {
        {28.65f * direction_B, 2.99f},{31.98f * direction_B, 1.74f},{31.6f * direction_B, 0.23f},{31.93f * direction_B, -1.29f},
        {30.43f * direction_B, -0.38f},{28.77f * direction_B, -1.12f},{24.29f * direction_B, -4.59f},{16.47f * direction_B, -5.28f},
        {10.7f * direction_B, -4.96f},{2.95f * direction_B, -10.29f},{8.55f * direction_B, -3.22f},{0.18f * direction_B, 1.29f},
        {9.57f * direction_B, -0.31f},{11.02f * direction_B, 0.27f},{22.82f * direction_B, 1.86f},{28.65f * direction_B, 2.99f}
    }, rgb_B, Tx_B, Ty_B, s_B);

    // wing
    polygon_B(
    {
        {22.82f * direction_B, birdWingY_B * 1.86f},
        {23.38f * direction_B, birdWingY_B * 8.57f},
        {9.98f * direction_B, birdWingY_B * 25.45f},
        {11.02f * direction_B, birdWingY_B * 0.27f}
    }, rgb_B, Tx_B, Ty_B, s_B);
}

#define MAX_BUBBLES 200
Bubble_B bubbles[MAX_BUBBLES];

//Rain drop
void addDrop_B()
{
    if (dropCount_B < MAX_DROPS)
    {
        dropX_B[dropCount_B] = rand() % 1000;  // x position
        dropY_B[dropCount_B] = 600;            // start at top
        dropSpeed_B[dropCount_B] = 7.0f + rand() % 8; // speed
        dropCount_B++;
    }
}

void drawRain_B()
{
    glColor3f(11/255.0f, 111/255.0f, 163/255.0f);

    glLineWidth(2.0f);
    glBegin(GL_LINES);
    for (int i = 0; i < dropCount_B; ++i)
    {
        glVertex2f(dropX_B[i], dropY_B[i]);
        glVertex2f(dropX_B[i], dropY_B[i] - 10); // line length
    }
    glEnd();
}
void drawBubbles_B()
{
    glColor3f(0.8f, 0.9f, 1.0f); // light blue
    for (int i = 0; i < MAX_BUBBLES; i++)
    {
        if (bubbles[i].active)
        {
            drawCircle_B(bubbles[i].x, bubbles[i].y, bubbles[i].radius);
        }
    }
}

void drawStars_B()
{

    if (currentMode_B==1 && isRaining_B==false)
    {
        glColor3f(1.0f, 1.0f, 1.0f); // White stars
        glPointSize(1.4f);           // Size of stars

        glBegin(GL_POINTS);

        glVertex2f(60, 575),glVertex2f(120, 560),glVertex2f(180, 570),glVertex2f(240, 540),glVertex2f(300, 580),
                   glVertex2f(360, 550),glVertex2f(420, 565),glVertex2f(480, 535),glVertex2f(540, 570),glVertex2f(600, 555),
                   glVertex2f(660, 565),glVertex2f(720, 540),glVertex2f(780, 575),glVertex2f(840, 550),glVertex2f(900, 565),
                   glVertex2f(960, 540),glVertex2f(80, 510),glVertex2f(150, 495),glVertex2f(220, 520),glVertex2f(290, 500),
                   glVertex2f(360, 515),glVertex2f(430, 485),glVertex2f(500, 510),glVertex2f(570, 490),glVertex2f(640, 505),
                   glVertex2f(710, 470),glVertex2f(780, 500),glVertex2f(850, 480),glVertex2f(920, 505),glVertex2f(980, 475),
                   glVertex2f(100, 450),glVertex2f(180, 460),glVertex2f(260, 440),glVertex2f(340, 455),glVertex2f(420, 430),
                   glVertex2f(500, 460),glVertex2f(580, 440),glVertex2f(660, 455),glVertex2f(740, 430),glVertex2f(820, 455),
                   glVertex2f(900, 440),glVertex2f(980, 450);

        glEnd();
    }
}

void drawSun_B()
{
    glLineWidth(1.5f);
    if (currentMode_B == 0)
    {
        if (isRaining_B == true)
        {
            glColor3f(1.0f, 0.820f, 0.643f); // morning rain sun
        }
        else
        {
            glColor3f(1.0f, 0.5f, 0.0f);     // normal morning sun
        }

        sunY_B = 500;
        //glColor3f(1.0, 0.5, 0.0);
        drawCircle_B(800, sunY_B, 40);
        for (int i = 0; i < 360; i += 30)
        {
            float rad = i * 3.1416 / 180.0;
            float x1 = 800 + cos(rad) * 50;
            float y1 = sunY_B + sin(rad) * 50;
            float x2 = 800 + cos(rad) * 70;
            float y2 = sunY_B + sin(rad) * 70;
            glBegin(GL_LINES);
            glVertex2f(x1, y1);
            glVertex2f(x2, y2);
            glEnd();
        }
    }
    else if (currentMode_B == 2)
    {
        // evening
        if (isRaining_B ==true)
        {
            glColor3f(0.651f, 0.290f, 0.196f);
            //glColor3f(1.0f, 0.698f, 0.482f);
        }
        else
        {
            glColor3f(1.0f, 0.2f, 0.0f);
        }

        sunY_B = 470;
        //glColor3f(1.0, 0.2, 0.0);
        drawCircle_B(750, sunY_B, 40);
        for (int i = 0; i < 360; i += 30)
        {
            float rad = i * 3.1416 / 180.0;
            float x1 = 750 + cos(rad) * 50;
            float y1 = sunY_B + sin(rad) * 50;
            float x2 = 750 + cos(rad) * 70;
            float y2 = sunY_B + sin(rad) * 70;
            glBegin(GL_LINES);
            glVertex2f(x1, y1);
            glVertex2f(x2, y2);
            glEnd();
        }
    }
}

void drawMoon_B()
{
    if (currentMode_B == 1)
    {
        if(isRaining_B == true)
        {
            glColor3f(0.839f, 0.839f, 0.839f); // moon color during rain

        }
        else
        {
            glColor3f(0.9, 0.9, 0.8); //normal moon color
        }
        //glColor3f(0.9, 0.9, 0.8);
        drawCircle_B(800, 550, 30);
        // Add some craters
        glColor3f(0.7, 0.7, 0.6);
        drawCircle_B(790, 560, 5);
        drawCircle_B(815, 540, 4);
        drawCircle_B(800, 530, 3);
    }
}

void drawCloud_B(float x, float y)
{
    if (isRaining_B==true)
    {
        glColor3f(0.639f, 0.624f, 0.616f);
    }
    else
    {
        if(currentMode_B==0) glColor3f(1.0, 1.0, 1.0);
        else if(currentMode_B==1) glColor3f(0.729f, 0.714f, 0.714f);
        else if(currentMode_B==2) glColor3f(0.949f, 0.859f, 0.780f);
    }
    //glColor3f(1.0, 1.0, 1.0);
    drawCircle_B(x, y, 15);
    drawCircle_B(x + 20, y, 15);
    drawCircle_B(x + 10, y + 10, 15);
    drawCircle_B(x + 30, y + 5, 12);
}

void line_B(float x1, float y1,float x2, float y2,float x3, float y3,
            float x4,float y4,float r, float g, float b)
{
    glLineWidth(2.0f);
    glColor3ub(r, g, b);
    glBegin(GL_LINES);
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);  // Top
    glVertex2f(x2, y2);
    glVertex2f(x3, y3);  // Right
    glVertex2f(x3, y3);
    glVertex2f(x4, y4);  // Bottom
    glVertex2f(x4, y4);
    glVertex2f(x1, y1);  // Left
    glEnd();
}

void singleLine_B(float x1, float y1,float x2, float y2,float r, float g, float b)
{
    glLineWidth(2.0f);       // Line thickness
    glColor3ub(r, g, b);      // Line color (RGB)
    glBegin(GL_LINES);
    glVertex2f(x1, y1);  // Start point
    glVertex2f(x2, y2);  // End point
    glEnd();
}

void quad_B(float x1, float y1,float x2, float y2,float x3, float y3,
            float x4, float y4,float r, float g, float b)
{
    glColor3ub(r,g,b);
    glBegin(GL_QUADS);
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);
    glVertex2f(x3, y3);
    glVertex2f(x4, y4);
    glEnd();
}

void triangle_B(float x, float y)
{
    glColor3f(0.0, 0.5, 0.0);
    for(int i = 0; i < 8; i++)
    {
        float angle = i * 45.0 * 3.1416 / 180.0;
        glBegin(GL_TRIANGLES);
        glVertex2f(x + 5, y + 80);
        glVertex2f(x + 5 + cos(angle) * 30, y + 80 + sin(angle) * 30);
        glVertex2f(x + 5 + cos(angle + 0.3) * 25, y + 80 + sin(angle + 0.3) * 25);
        glEnd();
    }
}

void draw_Circle_B(float cx, float cy, float r, float red, float green, float blue)
{
    glBegin(GL_TRIANGLE_FAN);
    glColor3f(red, green, blue);
    glVertex2f(cx, cy);
    for (int i = 0; i <= 360; i++)
    {
        float theta = i * 3.14159 / 180.0f;
        float x = cx + r * cos(theta);
        float y = cy + r * sin(theta);
        glVertex2f(x, y);
    }
    glEnd();
}
void birdAnimation_B()
{
    birdX_B += 1.5;    // move right
    birdWingY_B += 0.3;  // wing flapping
    if (birdWingY_B > 1) birdWingY_B = -1;

    // Reset bird when it goes off screen
    if (birdX_B > 1050) birdX_B = -100;
}
// function for control visibility of birds
void ControlBirds_B()
{
    if (currentMode_B == 0 || currentMode_B == 2)   // day or evening
    {
        bird_B(birdX_B-30, birdY_B-100, birdDirection_B, birdWingY_B, {0,0,0},1.0);
        bird_B(birdX_B, birdY_B-130, birdDirection_B, -birdWingY_B, {0,0,0},1.2);
        bird_B(birdX_B-30, birdY_B-160, birdDirection_B, birdWingY_B, {0,0,0},1.0);
    }
}

void building1_B()
{
    // Main building
    quad_B(0, 460, 185, 460, 185, 150, 0, 150, 128, 153, 204);
    line_B(0, 460, 185, 460, 185, 150, 0, 150, 0, 0, 0);

    // Building name
    glColor3f(0.0f, 0.0f, 0.0f);
    renderText_B(60, 440, GLUT_BITMAP_HELVETICA_18, "School");

    // Window grid parameters
    int startX = 10, startY = 430;   // Top-left of first window
    int winWidth = 40, winHeight = 30;
    int xGap = 20, yGap = 20;        // Gaps between windows
    int rows = 5, cols = 3;          // Number of windows (rows x columns)

    for (int r = 0; r < rows; r++)
    {
        for (int c = 0; c < cols; c++)
        {
            int x1 = startX + c * (winWidth + xGap);
            int y1 = startY - r * (winHeight + yGap);
            int x2 = x1 + winWidth;
            int y2 = y1 - winHeight;

            // Draw window
            quad_B(x1, y1, x2, y1, x2, y2, x1, y2, 255, 255, 255);
            line_B(x1, y1, x2, y1, x2, y2, x1, y2, 0, 0, 0);
        }
    }
}

void building2_B()
{
    // Main building body
    quad_B(185, 390, 370, 390, 370, 150, 185, 150, 211, 211, 211);
    line_B(185, 390, 370, 390, 370, 150, 185, 150, 0, 0, 0);

    // Roof strip
    quad_B(185, 400, 370, 400, 370, 390, 185, 390, 45, 27, 59);
    line_B(185, 400, 370, 400, 370, 390, 185, 390, 0, 0, 0);

    // Window grid parameters
    int startX = 200, startY = 370;  // top-left window
    int winWidth = 30, winHeight = 40;
    int xGap = 20, yGap = 50;       // space between windows
    int rows = 4, cols = 3;

    for (int r = 0; r < rows; r++)
    {
        for (int c = 0; c < cols; c++)
        {
            int x1 = startX + c * (winWidth + xGap);
            int y1 = startY - r * yGap;
            int x2 = x1 + winWidth;
            int y2 = y1 - winHeight;

            // Window background
            quad_B(x1, y1, x2, y1, x2, y2, x1, y2, 210, 227, 157);
            line_B(x1, y1, x2, y1, x2, y2, x1, y2, 0, 0, 0);

            // Horizontal middle bar
            singleLine_B(x1, y1 - winHeight / 2, x2, y1 - winHeight / 2, 0, 0, 0);

            // Vertical middle bar
            singleLine_B(x1 + winWidth / 2, y1, x1 + winWidth / 2, y2, 0, 0, 0);
        }
    }
}

void building3_B()
{
    // Main building body
    quad_B(350,495,500,495,500,150,350,150,211, 182, 131);
    line_B(350,495,500,495,500,150,350,150,0,0,0);

    // Roof
    quad_B(350,510,500,510,500,495,350,495,0,0,0);

    // Decorative vertical line
    singleLine_B(420,500,420,560,0,0,0);

    // Window properties
    int startX = 360,startY = 490;   // leftmost window x1
    int wWidth  = 20,wHeight = 20;    // window width
    int xGap = 15,yGap = 30;       // horizontal gap between windows
    int rows = 11,cols = 4;        // total rows

    // Draw windows
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            int x1 = startX + j * (wWidth + xGap);
            int y1 = startY - i * yGap;
            int x2 = x1 + wWidth;
            int y2 = y1 - wHeight;

            // Window color
            quad_B(x1, y1, x2, y1, x2, y2, x1, y2, 255, 255, 255);
            line_B(x1, y1, x2, y1, x2, y2, x1, y2, 0, 0, 0);
        }
    }
}

void building4_B()
{
    // Main building body
    quad_B(500, 420, 630, 420, 630, 150, 500, 150, 176, 163, 160);
    line_B(500, 420, 630, 420, 630, 150, 500, 150, 0, 0, 0);

    // Roof strip
    quad_B(500, 430, 630, 430, 630, 420, 500, 420, 120, 66, 72);
    line_B(500, 430, 630, 430, 630, 420, 500, 420, 0, 0, 0);

    // Window grid parameters
    int startX = 510, startY = 400; // top-left window
    int winWidth = 30, winHeight = 40;
    int xGap = 10, yGap = 60;       // space between windows
    int rows = 4, cols = 3;

    for (int r = 0; r < rows; r++)
    {
        for (int c = 0; c < cols; c++)
        {
            int x1 = startX + c * (winWidth + xGap);
            int y1 = startY - r * yGap;
            int x2 = x1 + winWidth;
            int y2 = y1 - winHeight;

            // Window background
            quad_B(x1, y1, x2, y1, x2, y2, x1, y2, 124, 126, 143);
            line_B(x1, y1, x2, y1, x2, y2, x1, y2, 0, 0, 0);

            // Horizontal middle bar
            singleLine_B(x1, y1 - winHeight / 2, x2, y1 - winHeight / 2, 0, 0, 0);

            // Vertical middle bar
            singleLine_B(x1 + winWidth / 2, y1, x1 + winWidth / 2, y2, 0, 0, 0);
        }
    }
}

void building5_B()
{
    // Main hospital building body
    quad_B(600, 480, 740, 480, 740, 430, 600, 430, 255, 255, 255);
    singleLine_B(600, 480, 740, 480, 0, 0, 0);
    singleLine_B(600, 430, 600, 480, 0, 0, 0);

    quad_B(630, 430, 740, 430, 740, 150, 630, 150, 255, 255, 255);
    singleLine_B(740, 480, 740, 150, 0, 0, 0);

    // "Hospital" text
    glColor3f(1.0f, 0.0f, 0.0f);
    renderText_B(640, 463, GLUT_BITMAP_HELVETICA_18, "Hospital");

    // --- Window grid ---
    int startX = 620, startY = 455; // Top-left window
    int winWidth = 20, winHeight = 20;
    int xGap = 40, yGap = 35; // Space between windows
    int rows = 9, cols = 3;

    for (int r = 0; r < rows; r++)
    {
        for (int c = 0; c < cols; c++)
        {
            int x1 = startX + c * xGap;
            int y1 = startY - r * yGap;
            int x2 = x1 + winWidth;
            int y2 = y1 - winHeight;

            quad_B(x1, y1, x2, y1, x2, y2, x1, y2, 153, 230, 255); // window
            line_B(x1, y1, x2, y1, x2, y2, x1, y2, 0, 0, 0);
        }
    }
}

void building6_B()
{
    // Main Building Body
    quad_B(740, 370, 880, 370, 880, 150, 740, 150, 211, 211, 211);
    line_B(740, 370, 880, 370, 880, 150, 740, 150, 0, 0, 0);

    int startX = 753,startY = 360;
    int winWidth = 20,winHeight = 20;
    int gapX = 30,gapY = 30;
    int rows = 7,cols = 4;

    for (int r = 0; r < rows; r++)
    {
        for (int c = 0; c < cols; c++)
        {
            int x1 = startX + c * gapX;
            int y1 = startY - r * gapY;
            int x2 = x1 + winWidth;
            int y2 = y1 - winHeight;

            // Window fill
            quad_B(x1, y1, x2, y1, x2, y2, x1, y2, 210, 227, 157);
            line_B(x1, y1, x2, y1, x2, y2, x1, y2, 0, 0, 0);
        }
    }
}


void building7_B()
{
    // Main building body
    quad_B(880, 495, 1000, 495, 1000, 150, 880, 150, 211, 182, 131);
    line_B(880, 495, 1000, 495, 1000, 150, 880, 150, 0, 0, 0);

    // Roof
    quad_B(880, 510, 1000, 510, 1000, 495, 880, 495, 0, 0, 0);

    singleLine_B(940, 500, 940, 560, 0, 0, 0);

    // Window properties
    int startX = 890, startY = 490; // top-left window
    int wWidth = 20, wHeight = 20;  // window size
    int xGap = 40, yGap = 30;       // horizontal and vertical spacing
    int rows = 11, cols = 3;        // total rows and columns

    // Draw windows using nested loops
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            int x1 = startX + j * xGap;
            int y1 = startY - i * yGap;
            int x2 = x1 + wWidth;
            int y2 = y1 - wHeight;

            // Window color
            quad_B(x1, y1, x2, y1, x2, y2, x1, y2, 255, 255, 255);
            line_B(x1, y1, x2, y1, x2, y2, x1, y2, 0, 0, 0);
        }
    }
}

void drawTree_B()
{
    // 1st tree
    quad_B(52,150,62,150, 62,190, 52,190, 102, 51, 0);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(47, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(67, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(57, 212, 20);

    // 2nd tree
    quad_B(152,150, 162,150, 162,190, 152,190, 102, 51, 0);
    glColor3f(0.1, 0.6, 0.1);
    drawCircle_B(147, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(167, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(157, 212, 20);

    // 3rd tree
    quad_B(262,150, 272,150, 272,190, 262,190, 102, 51, 0);
    glColor3f(0.1, 0.6, 0.1);
    drawCircle_B(257, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(277, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(267, 212, 20);

    // 4th tree
    quad_B(362,150, 372,150, 372,190, 362,190, 102, 51, 0);
    glColor3f(0.1, 0.6, 0.1);
    drawCircle_B(357, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(377, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(367, 212, 20);

    // 5th tree
    quad_B(462,150, 472,150, 472,190, 462,190, 102, 51, 0);
    glColor3f(0.1, 0.6, 0.1);
    drawCircle_B(457, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(477, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(467, 212, 20);

    // 6th tree
    quad_B(562,150, 572,150, 572,190, 562,190, 102, 51, 0);
    glColor3f(0.1, 0.6, 0.1);
    drawCircle_B(557, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(577, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(567, 212, 20);

    // 7th tree
    quad_B(662,150, 672,150, 672,190, 662,190, 102, 51, 0);
    glColor3f(0.1, 0.6, 0.1);
    drawCircle_B(657, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(677, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(667, 212, 20);

    // 8th tree
    quad_B(762,150, 772,150, 772,190, 762,190, 102, 51, 0);
    glColor3f(0.1, 0.6, 0.1);
    drawCircle_B(757, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(777, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(767, 212, 20);

    // 9th tree
    quad_B(862,150, 872,150, 872,190, 862,190, 102, 51, 0);
    glColor3f(0.1, 0.6, 0.1);
    drawCircle_B(857, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(877, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(867, 212, 20);

    // 10th tree
    quad_B(962,150, 972,150, 972,190, 962,190, 102, 51, 0);
    glColor3f(0.1, 0.6, 0.1);
    drawCircle_B(957, 200, 18);
    glColor3f(0.0, 0.55, 0.0);
    drawCircle_B(977, 200, 18);
    glColor3f(0.0, 0.5, 0.0);
    drawCircle_B(967, 212, 20);
}

void drawPalmTree_B()
{
    quad_B(200,150,210,150,208,230,202,230,179, 128, 77);
    triangle_B(200,150);
    quad_B(420,150,430,150,428,230,422,230,179, 128, 77);
    triangle_B(420,150);
    quad_B(800,150,810,150,808,230,802,230,179, 128, 77);
    triangle_B(800,150);

}
void Car_B()
{
    // Main body (shifted by carX)
    quad_B(190 + carX_B, 285, 280 + carX_B, 285, 280 + carX_B, 270, 190 + carX_B, 270,30, 53, 66);
    line_B(190 + carX_B, 285, 280 + carX_B, 285, 280 + carX_B, 270, 190 + carX_B, 270, 1, 1, 1);

    // window part
    glColor3ub(1, 1, 1);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX_B, 285.0);
    glVertex2f(220.0 + carX_B, 300.0);
    glVertex2f(250.0 + carX_B,  300.0);
    glVertex2f(260.0 + carX_B, 285.0);
    glEnd();
    glColor3ub(147, 176, 196);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX_B, 283.0);
    glVertex2f(220.0 + carX_B, 298.0);
    glVertex2f(250.0 + carX_B,  298.0);
    glVertex2f(260.0 + carX_B, 283.0);
    glEnd();

    // Wheels
    glColor3ub(17, 23, 28);
    drawCircle_B(213 + carX_B, 271, 9);
    drawCircle_B(252 + carX_B, 271, 9);

    glColor3f(0.0f, 0.0f, 0.0f);
    drawCircle_B(213 + carX_B, 270, 6);
    drawCircle_B(252 + carX_B, 270, 6);

    glColor3f(1.0f, 1.0f, 1.0f);
    drawCircle_B(213 + carX_B, 270, 2);
    drawCircle_B(252 + carX_B, 270, 2);
    if(currentMode_B==1 || currentMode_B ==2)
    {
        glColor3ub(204, 214, 227);


        glBegin(GL_POLYGON);
        glVertex2f(175.0 + carX_B, 292.0);
        glVertex2f(190.0 + carX_B, 282.0);
        glVertex2f(190.0 + carX_B,  272.0);
        glVertex2f(175.0 + carX_B, 260.0);
        glEnd();
    }
    //2nd car
    // Body
    quad_B(190 + carX2_B, 275, 280 + carX2_B, 275, 280 + carX2_B, 260, 190 + carX2_B, 260, 57, 54, 89);
    line_B(190 + carX2_B, 275, 280 + carX2_B, 275, 280 + carX2_B, 260, 190 + carX2_B, 260, 1, 1, 1);

// window part
    glColor3ub(1, 1, 1);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX2_B, 275.0);
    glVertex2f(220.0 + carX2_B, 290.0);
    glVertex2f(250.0 + carX2_B,  290.0);
    glVertex2f(260.0 + carX2_B, 275.0);
    glEnd();
    glColor3ub(147, 176, 196);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX2_B, 273.0);
    glVertex2f(220.0 + carX2_B, 288.0);
    glVertex2f(250.0 + carX2_B,  288.0);
    glVertex2f(260.0 + carX2_B, 273.0);
    glEnd();

    // Wheels
    glColor3ub(17, 23, 28);
    drawCircle_B(213 + carX2_B, 261, 9);
    drawCircle_B(252 + carX2_B, 261, 9);

    glColor3f(0.0f, 0.0f, 0.0f);
    drawCircle_B(213 + carX2_B, 260, 6);
    drawCircle_B(252 + carX2_B, 260, 6);

    glColor3f(1.0f, 1.0f, 1.0f);
    drawCircle_B(213 + carX2_B, 260, 2);
    drawCircle_B(252 + carX2_B, 260, 2);
    if(currentMode_B==1 || currentMode_B ==2)
    {
        glColor3ub(204, 214, 227);


        glBegin(GL_POLYGON);
        glVertex2f(175.0 + carX2_B, 282.0);
        glVertex2f(190.0 + carX2_B, 272.0);
        glVertex2f(190.0 + carX2_B,  262.0);
        glVertex2f(175.0 + carX2_B, 252.0);
        glEnd();
    }

// 3rd car Body
    quad_B(190 + carX3_B, 275, 280 + carX3_B, 275, 280 + carX3_B, 260, 190 + carX3_B, 260,54, 36, 39);
    line_B(190 + carX3_B, 275, 280 + carX3_B, 275, 280 + carX3_B, 260, 190 + carX3_B, 260, 1, 1, 1);
// window part
    glColor3ub(1, 1, 1);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX3_B, 275.0);
    glVertex2f(220.0 + carX3_B, 290.0);
    glVertex2f(250.0 + carX3_B,  290.0);
    glVertex2f(260.0 + carX3_B, 275.0);
    glEnd();
    glColor3ub(147, 176, 196);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX3_B, 273.0);
    glVertex2f(220.0 + carX3_B, 288.0);
    glVertex2f(250.0 + carX3_B,  288.0);
    glVertex2f(260.0 + carX3_B, 273.0);
    glEnd();

    // Wheels
    glColor3ub(17, 23, 28);
    drawCircle_B(213 + carX3_B, 261, 9);
    drawCircle_B(252 + carX3_B, 261, 9);

    glColor3f(0.0f, 0.0f, 0.0f);
    drawCircle_B(213 + carX3_B, 260, 6);
    drawCircle_B(252 + carX3_B, 260, 6);

    glColor3f(1.0f, 1.0f, 1.0f);
    drawCircle_B(213 + carX3_B, 260, 2);
    drawCircle_B(252 + carX3_B, 260, 2);
    if(currentMode_B==1 || currentMode_B ==2)
    {
        glColor3ub(204, 214, 227);


        glBegin(GL_POLYGON);
        glVertex2f(175.0 + carX3_B, 282.0);
        glVertex2f(190.0 + carX3_B, 272.0);
        glVertex2f(190.0 + carX3_B,  262.0);
        glVertex2f(175.0 + carX3_B, 252.0);
        glEnd();
    }

}
//function for draw car on road
void Car2_B()
{
    float carY_B = -170.0f;// move all cars down
    float carY2_B = -130.0f;
    float carY3_B = -160.0f;


    // 1st car
    quad_B(190 + carX4_B, 275 + carY_B, 280 + carX4_B, 275 + carY_B, 280 + carX4_B,
           260 + carY_B, 190 +carX4_B, 260 + carY_B, 102, 25, 37);
    line_B(190 + carX4_B, 275 + carY_B, 280 + carX4_B, 275 + carY_B,
           280 + carX4_B, 260 + carY_B, 190 + carX4_B, 260 + carY_B, 1, 1, 1);

    // window part
    glColor3ub(1, 1, 1);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX4_B, 275.0 + carY_B);
    glVertex2f(220.0 + carX4_B, 290.0 + carY_B);
    glVertex2f(250.0 + carX4_B, 290.0 + carY_B);
    glVertex2f(260.0 + carX4_B, 275.0 + carY_B);
    glEnd();
    glColor3ub(147, 176, 196);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX4_B, 273.0 + carY_B);
    glVertex2f(220.0 + carX4_B, 288.0 + carY_B);
    glVertex2f(250.0 + carX4_B, 288.0 + carY_B);
    glVertex2f(260.0 + carX4_B, 273.0 + carY_B);
    glEnd();

    // Wheels
    glColor3ub(17, 23, 28);
    drawCircle_B(213 + carX4_B, 261 + carY_B, 9);
    drawCircle_B(252 + carX4_B, 261 + carY_B, 9);
    glColor3f(1.0f, 1.0f, 1.0f);
    drawCircle_B(213 + carX4_B, 260 + carY_B, 6);
    drawCircle_B(252 + carX4_B, 260 + carY_B, 6);
    glColor3f(0.0f, 0.0f, 0.0f);
    drawCircle_B(213 + carX4_B, 260 + carY_B, 4);
    drawCircle_B(252 + carX4_B, 260 + carY_B, 4);

    // Headlight
    if(currentMode_B==1 || currentMode_B ==2)
    {
        glColor3ub(204, 214, 227);
        glBegin(GL_POLYGON);
        glVertex2f(175.0 + carX4_B, 282.0 + carY_B);
        glVertex2f(190.0 + carX4_B, 272.0 + carY_B);
        glVertex2f(190.0 + carX4_B, 262.0 + carY_B);
        glVertex2f(175.0 + carX4_B, 252.0 + carY_B);
        glEnd();
    }

    // 2nd car
    quad_B(190 + carX5_B, 275 + carY2_B, 280 + carX5_B, 275 + carY2_B,
           280 + carX5_B, 260 + carY2_B, 190 + carX5_B, 260 + carY2_B, 94, 83, 84);
    line_B(190 + carX5_B, 275 + carY2_B, 280 + carX5_B, 275 + carY2_B,
           280 + carX5_B, 260 + carY2_B, 190 + carX5_B, 260 + carY2_B, 1, 1, 1);

    glColor3ub(1, 1, 1);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX5_B, 275.0 + carY2_B);
    glVertex2f(220.0 + carX5_B, 290.0 + carY2_B);
    glVertex2f(250.0 + carX5_B, 290.0 +carY2_B);
    glVertex2f(260.0 + carX5_B, 275.0 + carY2_B);
    glEnd();
    glColor3ub(147, 176, 196);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX5_B, 273.0 + carY2_B);
    glVertex2f(220.0 + carX5_B, 288.0 + carY2_B);
    glVertex2f(250.0 + carX5_B, 288.0 +carY2_B);
    glVertex2f(260.0 + carX5_B, 273.0 + carY2_B);
    glEnd();

    // Wheels
    glColor3ub(17, 23, 28);
    drawCircle_B(213 + carX5_B, 261 + carY2_B, 9);
    drawCircle_B(252 + carX5_B, 261 + carY2_B, 9);
    glColor3f(1.0f, 1.0f, 1.0f);
    drawCircle_B(213 + carX5_B, 260 + carY2_B, 6);
    drawCircle_B(252 + carX5_B, 260 + carY2_B, 6);
    glColor3f(0.0f, 0.0f, 0.0f);
    drawCircle_B(213 + carX5_B, 260 + carY2_B, 4);
    drawCircle_B(252 + carX5_B, 260 + carY2_B, 4);

    if(currentMode_B==1 || currentMode_B ==2)
    {
        glColor3ub(204, 214, 227);
        glBegin(GL_POLYGON);
        glVertex2f(175.0 + carX5_B, 282.0 + carY2_B);
        glVertex2f(190.0 + carX5_B, 272.0 + carY2_B);
        glVertex2f(190.0 + carX5_B, 262.0 + carY2_B);
        glVertex2f(175.0 + carX5_B, 252.0 + carY2_B);
        glEnd();
    }

    // 3rd car
    quad_B(190 + carX6_B, 275 + carY3_B, 280 + carX6_B, 275 + carY3_B,
           280 + carX6_B, 260 + carY3_B, 190 + carX6_B, 260 + carY3_B, 49, 64, 39);
    line_B(190 + carX6_B, 275 + carY3_B, 280 + carX6_B, 275 + carY3_B,
           280 + carX6_B, 260 + carY3_B, 190 + carX6_B, 260 + carY3_B, 1, 1, 1);

    glColor3ub(1, 1, 1);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX6_B, 275.0 + carY3_B);
    glVertex2f(220.0 + carX6_B, 290.0 + carY3_B);
    glVertex2f(250.0 + carX6_B, 290.0 + carY3_B);
    glVertex2f(260.0 + carX6_B, 275.0 + carY3_B);
    glEnd();
    glColor3ub(147, 176, 196);
    glBegin(GL_POLYGON);
    glVertex2f(210.0 + carX6_B, 273.0 + carY3_B);
    glVertex2f(220.0 + carX6_B, 288.0 + carY3_B);
    glVertex2f(250.0 + carX6_B, 288.0 + carY3_B);
    glVertex2f(260.0 + carX6_B, 273.0 + carY3_B);
    glEnd();

    glColor3ub(17, 23, 28);
    drawCircle_B(213 + carX6_B, 261 + carY3_B, 9);
    drawCircle_B(252 + carX6_B, 261 + carY3_B, 9);
    glColor3f(1.0f, 1.0f, 1.0f);
    drawCircle_B(213 + carX6_B, 260 + carY3_B, 6);
    drawCircle_B(252 + carX6_B, 260 + carY3_B, 6);
    glColor3f(0.0f, 0.0f, 0.0f);
    drawCircle_B(213 + carX6_B, 260 + carY3_B, 4);
    drawCircle_B(252 + carX6_B, 260 + carY3_B, 4);

    if(currentMode_B==1 || currentMode_B ==2)
    {
        glColor3ub(204, 214, 227);
        glBegin(GL_POLYGON);
        glVertex2f(175.0 + carX6_B, 282.0 + carY3_B);
        glVertex2f(190.0 + carX6_B, 272.0 +carY3_B);
        glVertex2f(190.0 + carX6_B, 262.0 + carY3_B);
        glVertex2f(175.0 + carX6_B, 252.0 + carY3_B);
        glEnd();
    }
}

void drawBus_B(float x, float y)
{
    // Main body
    quad_B(x, y, x + 120, y, x + 120, y + 45, x, y + 45, 245, 204, 26); // Bus body

    // Front cabin (polygon converted to quad_B as rectangle)
    quad_B(x + 90, y, x + 120, y, x + 120, y + 25, x + 100, y + 45, 245, 204, 26); // Front cabin

    // Windows
    for (int i = 0; i < 5; i++)
    {
        quad_B(x + 10 + i * 16, y + 25,
               x + 22 + i * 16, y + 25,
               x + 22 + i * 16, y + 40,
               x + 10 + i * 16, y + 40,
               179, 229, 255);
    }
    // Front window
    quad_B(x + 95, y + 15, x + 115, y + 15, x + 115, y + 30, x + 95, y + 30, 179, 229, 255);

    // Door
    quad_B(x + 90, y + 10, x + 105, y + 10, x + 105, y + 40, x + 90, y + 40, 102, 51, 0);

    // Door handle
    quad_B(x + 92, y + 20, x + 103, y + 20, x + 103, y + 25, x + 92, y + 25, 153, 153, 153);

    // Wheels
    glColor3f(0.1, 0.1, 0.1);
    drawCircle_B(x + 25, y, 12);
    drawCircle_B(x + 95, y, 12);
    glColor3f(0.3, 0.3, 0.3);
    drawCircle_B(x + 25, y, 8);
    drawCircle_B(x + 95, y, 8);

    // Wheel rims
    glColor3f(0.7, 0.7, 0.7);
    drawCircle_B(x + 25, y, 5);
    drawCircle_B(x + 95, y, 5);

    // Bus number
    glColor3f(0.1, 0.1, 0.1);
    glRasterPos2f(x + 50, y + 15);
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, '2');
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, '0');
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, '4');

    // Side details (lines)
    glColor3f(0.7, 0.7, 0.7);
    glBegin(GL_LINES);
    glVertex2f(x + 10, y + 10);
    glVertex2f(x + 110, y + 10);
    glEnd();

    // Front grille (lines)
    glColor3f(0.2, 0.2, 0.2);
    glBegin(GL_LINES);
    for(int i = 0; i < 5; i++)
    {
        glVertex2f(x + 100, y + 10 + i * 3);
        glVertex2f(x + 115, y + 10 + i * 3);
    }
    glEnd();

    if (currentMode_B == 1 || currentMode_B == 2)
    {
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glColor4f(1.0, 1.0, 0.8, 0.4);  // Soft yellow light

        glBegin(GL_POLYGON);
        glVertex2f(x + 115, y + 10);   // Bottom-left (bus side)
        glVertex2f(x + 115, y + 25);  // Top-left (bus side)
        glVertex2f(x + 200, y + 45);  // Top-right (far front)
        glVertex2f(x + 200, y-13 );   // Bottom-right (far front)
        glEnd();

        glDisable(GL_BLEND);
    }
}

void drawAmbulance_B(float x, float y)
{
    // Main body
    glColor3f(0.95, 0.0, 0.0);
    quad_B(x, y, x + 100, y, x + 100, y + 35, x, y + 35, 242, 0, 0); // body

    // Front cabin
    glColor3f(0.95, 0.0, 0.0);
    glBegin(GL_POLYGON);
    glVertex2f(x + 70, y);
    glVertex2f(x + 100, y);
    glVertex2f(x + 100, y + 25);
    glVertex2f(x + 80, y + 35);
    glEnd();

    // Windows
    glColor3f(0.7, 0.9, 1.0);
    quad_B(x + 5, y + 15,x + 30, y + 15,x + 30, y + 30,x + 5,  y + 30,179, 230, 255); // Side window

    quad_B(x + 75, y + 10,x + 95, y + 10,x + 95, y + 25,x + 75, y + 25,179, 230, 255); // Front window

    // Side stripe
    glColor3f(1.0, 1.0, 1.0);
    quad_B(x + 5,  y + 30,x + 95, y + 30,x + 95, y + 35,x + 5,  y + 35,255, 255, 255); // Side stripe

    // Red cross
    glColor3f(1.0, 1.0, 1.0);
    quad_B(x + 40, y + 32,x + 60, y + 32,x + 60, y + 42,x + 40, y + 42,255, 255, 255); // Red cross horizontal bar

    glColor3f(0.95, 0.0, 0.0);
    glBegin(GL_LINES);
    glVertex2f(x + 40, y + 37);
    glVertex2f(x + 60, y + 37);
    glVertex2f(x + 50, y + 32);
    glVertex2f(x + 50, y + 42);
    glEnd();

    // Wheels
    glColor3f(0.1, 0.1, 0.1);
    drawCircle_B(x + 20, y, 10);
    drawCircle_B(x + 80, y, 10);
    glColor3f(0.3, 0.3, 0.3);
    drawCircle_B(x + 20, y, 6);
    drawCircle_B(x + 80, y, 6);

    // Wheel rims
    glColor3f(0.7, 0.7, 0.7);
    drawCircle_B(x + 20, y, 4);
    drawCircle_B(x + 80, y, 4);

    // Siren light
    sirenTimer_B += 0.1;
    if (sirenTimer_B > 0.5)
    {
        sirenOn_B = !sirenOn_B;
        sirenTimer_B = 0;
    }

    if (sirenOn_B)
    {
        glColor3f(1.0, 0.8, 0.0);
        quad_B(x + 45, y + 35,x + 55, y + 35,x + 55, y + 45,x + 45, y + 45,255, 204, 0); // Siren light

        // Siren glow
        if (currentMode_B == 1 || currentMode_B == 2)
        {
            glEnable(GL_BLEND);
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            glColor4f(1.0, 0.8, 0.0, 0.3);
            drawCircle_B(x + 50, y + 40, 15);
            glDisable(GL_BLEND);
        }
    }

    // Headlights  only on during night/evening
    if (currentMode_B == 1 || currentMode_B == 2)
    {
        // Main headlights
        glColor3f(1.0, 1.0, 0.9);
        quad_B(x + 95, y + 5,x + 100, y + 5,x + 100, y + 10,x + 95, y + 10,255, 255, 230); // Headlight bottom
        quad_B(x + 95, y + 20,x + 100, y + 20,x + 100, y + 25,x + 95, y + 25,255, 255, 230); // Headlight top

        // Light beams
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glColor4f(1.0, 1.0, 0.8, 0.4);
        glBegin(GL_POLYGON);
        glVertex2f(x + 100, y + 5);   // bottom near point
        glVertex2f(x + 100, y + 25);  // top near point
        glVertex2f(x + 150, y + 45);  // top far point
        glVertex2f(x + 150, y - 15);
        glEnd();
        glDisable(GL_BLEND);
    }

    // Front grille
    glColor3f(0.2, 0.2, 0.2);
    glBegin(GL_LINES);
    for(int i = 0; i < 5; i++)
    {
        glVertex2f(x + 90, y + 10 + i*3);
        glVertex2f(x + 95, y + 10 + i*3);
    }
    glEnd();

    // Side details
    glColor3f(0.8, 0.8, 0.8);
    glBegin(GL_LINES);
    glVertex2f(x + 30, y + 10);
    glVertex2f(x + 70, y + 10);
    glEnd();
}

void Bridge_Track_B()
{
    //full bridge
    quad_B(0,280,1000,280,1000,250,0,250,70, 71, 70);
    line_B(0,280,1000,280,1000,250,0,250,0, 0, 0);

    // Road markings
    for (int i = 0; i < 1000; i += 40)
    {
        if (i % 80 < 40)
        {
            quad_B(i,265,i+38,265,i+38,268,i,268,255,255, 255);
        }
    }

    // Side barriers
    for (int i = 0; i < 1000; i += 10)
    {
        singleLine_B(i, 280,i, 295,77, 51, 26);
    }
    singleLine_B(0, 295,1000, 295,77, 51, 26);
    singleLine_B(0, 290,1000, 290,77, 51, 26);

}

void Pillar_Structure_B()
{
    // Support pillars size
    for (int x = 0; x <= 1000; x += 120)
    {
        quad_B(x, 250,x + 21, 250,x + 21, 150,x, 150,64, 64, 38);
        line_B(x, 250,x + 21, 250,x + 21, 150,x, 150,0, 0, 0);
    }
    // Road base
    quad_B(0, 250,1000,250,1000,245,0,245,38, 38, 34);
    line_B(0, 250,1000,250,1000,245,0,245,0,0,0);
}

void Road_B()
{
    quad_B(0,150,1000,150,1000,0,0,0,38, 38, 34);
    line_B(0,150,1000,150,1000,0,0,0,0,0,0);

    // Lane markings
    for (int i = 0; i < 1000; i += 40)
    {
        if (i % 80 < 40)
        {
            quad_B(i, 70,i + 55, 70,i + 55, 75,i, 75,255,255,255);
        }
    }
}

void lampPost_B(float x, float y)
{
    // Vertical pole
    quad_B(x + 18, y, x + 24, y, x + 24, y + 80, x + 18, y + 80, 0.4, 0.4, 0.4);

    // Top arch connector (curved)
    glColor3f(0.4, 0.4, 0.4);
    glLineWidth(4.5);
    glBegin(GL_LINE_STRIP);
    for (int i = 0; i <= 180; i++)
    {
        float theta = i * 3.14159 / 180.0f;
        float arcX = x + 20 + 10 * cos(theta);
        float arcY = y + 72 + 10 * sin(theta);
        glVertex2f(arcX, arcY);
    }
    glEnd();

    // Left lamp body (hanging)
    quad_B(x + 8, y + 62, x + 12, y + 62, x + 12, y + 72, x + 8, y + 72, 0.4, 0.4, 0.4);

    // Right lamp body (hanging)
    quad_B(x + 28, y + 62, x + 32, y + 62, x + 32, y + 72, x + 28, y + 72, 0.4, 0.4, 0.4);

    if (currentMode_B == 1 || currentMode_B == 2)
    {
        // Night mode  glowing yellow
        draw_Circle_B(x + 10, y + 62, 4, 1.0, 1.0, 0.0);
        draw_Circle_B(x + 30, y + 62, 4, 1.0, 1.0, 0.0);

        // Optional glow halo for extra effect
        glColor4f(1.0, 1.0, 0.0, 0.2);
        draw_Circle_B(x + 10, y + 62, 8, 1.0, 1.0, 0.0);
        draw_Circle_B(x + 30, y + 62, 8, 1.0, 1.0, 0.0);

    }
    else
    {
        // Day mode  bulbs look OFF (dark gray)
        draw_Circle_B(x + 10, y + 62, 4, 1.0, 1.0, 1.0);
        draw_Circle_B(x + 30, y + 62, 4, 1.0, 1.0, 1.0);
    }
}

void update_B(int value)
{

    carX_B  -= carSpeed_B+0.2;
    carX2_B -= carSpeed2_B;
    carX3_B -= carSpeed3_B;

// Reset cars when they go off screen
    if (carX_B < -600)  carX_B = 900;
    if (carX2_B < -600) carX2_B = 900;
    if (carX3_B < -600) carX3_B = 900;

    carX4_B -= carSpeed_B+1;
    carX5_B -= carSpeed2_B+0.7;
    carX6_B-= carSpeed3_B;

// Reset cars when they go off screen
    if (carX4_B < -600)  carX4_B = 900;
    if (carX5_B < -600) carX5_B = 900;
    if (carX6_B < -600) carX6_B = 900;

    busX_B += 1.5;
    if (busX_B > 1000) busX_B = -150;

    ambulanceX_B += 2.2;
    if (ambulanceX_B > 1000) ambulanceX_B = -120;


    if (isRaining_B)
    {
        // randomly add new drops
        if (rand() % 2 == 0) addDrop_B();

        // move drops
        for (int i = 0; i < dropCount_B; ++i)
        {
            dropY_B[i] -= dropSpeed_B[i];

            // If the drop reaches the ground
            if (dropY_B[i] <= 10)
            {
                // ground level
                for (int j = 0; j < MAX_BUBBLES; j++)
                {
                    if (!bubbles[j].active)
                    {
                        bubbles[j].x = dropX_B[i];
                        bubbles[j].y = 10; // ground
                        bubbles[j].radius = 2.0f;
                        bubbles[j].active = true;
                        break;
                    }
                }
                // Reset the drop
                dropY_B[i] = 600;
                dropX_B[i] = rand() % 1000;
            }
        }

    }
    for (int i = 0; i < MAX_BUBBLES; i++)
    {
        if (bubbles[i].active)
        {
            bubbles[i].radius += 0.3f; // bubble expands
            if (bubbles[i].radius > 8.0f)
            {
                // max size
                bubbles[i].active = false;
            }
        }
    }
    // Update cloud positions separately for smoother movement
    cloudX1_B += cloudSpeed_B;
    cloudX2_B += cloudSpeed_B;
    cloudX3_B += cloudSpeed_B;
    cloudX4_B += cloudSpeed_B;
    if (cloudX1_B > 1000) cloudX1_B = -200;
    if (cloudX2_B > 1000) cloudX2_B = -200;
    if (cloudX3_B > 1000) cloudX3_B = -200;
    if (cloudX4_B > 1000) cloudX4_B = -200;

    birdAnimation_B();

    glutPostRedisplay();
    glutTimerFunc(16, update_B, 0);
}
void display_B()
{

    if(isRaining_B)
    {
        // Sky color when raining
        if(currentMode_B == 0) glClearColor(0.422f, 0.492f, 0.496f, 1.0f);  // morning rain
        else if(currentMode_B == 1) glClearColor(0.102f, 0.122f, 0.149f, 1.0f); // rainy night sky
        else if(currentMode_B == 2) glClearColor(0.341f, 0.196f, 0.090f, 1.0f); //  rainy evening sky
    }
    else
    {
        // Normal sky color
        if(currentMode_B == 0) glClearColor(0.6f, 0.9f, 1.0f, 1.0f); // morning
        else if(currentMode_B == 2) glClearColor(0.8f, 0.5f, 0.2f, 1.0f); // evening
        else if(currentMode_B == 1) glClearColor(0.0f, 0.0f, 0.1f, 1.0f); // night
    }
    glClear(GL_COLOR_BUFFER_BIT);

    drawSun_B();
    drawMoon_B();
    drawStars_B();

    building1_B();
    building2_B();
    building3_B();
    building5_B();
    building4_B();
    building6_B();
    building7_B();

    glBegin(GL_LINES);
    glColor3f(0.0f, 0.0f, 0.0f);  // Black line
    glLineWidth(5.0f);
    glVertex2f(0, 150);     // Left edge
    glVertex2f(1000, 150);  // Right edge
    glEnd();

    Road_B();

    drawBus_B(busX_B, 28);
    drawAmbulance_B(ambulanceX_B, 12);

    drawTree_B();
    drawPalmTree_B();

    Bridge_Track_B();
    Pillar_Structure_B();

    lampPost_B(500, 150);
    lampPost_B(700, 150);
    lampPost_B(300, 150);
    lampPost_B(900, 150);
    lampPost_B(100, 150);
    lampPost_B(500, 0);
    lampPost_B(700, 0);
    lampPost_B(300, 0);
    lampPost_B(900, 0);
    lampPost_B(100, 0);

    Car_B();
    Car2_B();

    // Draw clouds at separate positions
    drawCloud_B(cloudX1_B, 500);
    drawCloud_B(cloudX2_B, 520);
    drawCloud_B(cloudX3_B, 550);
    drawCloud_B(cloudX4_B, 560);

    ControlBirds_B();

    if (isRaining_B) drawRain_B();

    drawBubbles_B();

    //glutSwapBuffers();
    //glFlush();
}
void Scene_B()
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0,1000,0,600);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    display_B();
}

///scene c
// Helper function to draw a filled circle
void drawFilledCircle(float cx, float cy, float r, int segments) {
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(cx, cy);
    for (int i = 0; i <= segments; i++) {
        float theta = 2.0f * M_PI * float(i) / float(segments);
        float x = r * cosf(theta);
        float y = r * sinf(theta);
        glVertex2f(x + cx, y + cy);
    }
    glEnd();
}

// Helper function to draw a circle outline
void drawCircleOutline(float cx, float cy, float r, int segments) {
    glBegin(GL_LINE_LOOP);
    for (int i = 0; i < segments; i++) {
        float theta = 2.0f * M_PI * float(i) / float(segments);
        glVertex2f(cx + r * cosf(theta), cy + r * sinf(theta));
    }
    glEnd();
}

// Draw the Novo Theatre Dome (simplified)
// Simplified Novo Theatre Dome (front view)
// Draw a dome made of small square-like tiles
void drawDomeTiles(float cx, float cyBase, float radius, int rows = 6, int cols = 12) {
    for (int r = 0; r < rows; r++) {
        float y0 = cyBase + radius * float(r) / rows;
        float y1 = cyBase + radius * float(r + 1) / rows;

        // Compute horizontal half-width at this row based on half-circle
        float halfWidth0 = radius * sqrtf(1.0f - powf(float(r)/rows, 2));
        float halfWidth1 = radius * sqrtf(1.0f - powf(float(r+1)/rows, 2));

        for (int c = 0; c < cols; c++) {
            float x0 = -halfWidth0 + 2.0f * halfWidth0 * c / cols;
            float x1 = -halfWidth0 + 2.0f * halfWidth0 * (c + 1) / cols;
            float x2 = -halfWidth1 + 2.0f * halfWidth1 * (c + 1) / cols;
            float x3 = -halfWidth1 + 2.0f * halfWidth1 * c / cols;

            // simple color variation for tile effect
            float shade = 0.2f + 0.1f * ((r+c)%2);
            glColor3f(0.2f + shade, 0.4f + shade*0.2f, 0.7f);

            glBegin(GL_QUADS);
                glVertex2f(cx + x0, y0);
                glVertex2f(cx + x1, y0);
                glVertex2f(cx + x2, y1);
                glVertex2f(cx + x3, y1);
            glEnd();
        }
    }
}


void drawNovoTheatreDome() {

    float cx = 0.0f, cyBase = 0.5f, radius = 5.0f;
    drawDomeTiles(cx, cyBase, radius);

    // Base color (night/day)
    float r = nightMode ? 0.1f : 0.15f;
    float g = nightMode ? 0.3f : 0.40f;
    float b = nightMode ? 0.5f : 0.70f;

    int segments = 100; // higher = smoother

    // -------- Main Dome (smooth semi-circle) --------
    glBegin(GL_TRIANGLE_FAN);
        glColor3f(r, g, b);          // center color
        glVertex2f(cx, cyBase);      // center of base

        for (int i = 0; i <= segments; i++) {
            float angle = M_PI * i / segments;      // 0..π
            float x = cx + radius * cosf(angle);
            float y = cyBase + radius * sinf(angle);
            // subtle gradient for a soft highlight
            float t = sinf(angle * 0.5f);
            glColor3f(r + 0.15f * t, g + 0.15f * t, b + 0.15f * t);
            glVertex2f(x, y);
        }
    glEnd();

    // -------- Dome base strip --------
    glColor3f(r * 0.9f, g * 0.9f, b * 0.9f);
    glBegin(GL_QUADS);
        glVertex2f(cx - radius, cyBase);
        glVertex2f(cx + radius, cyBase);
        glVertex2f(cx + radius, cyBase + radius * 0.1f);
        glVertex2f(cx - radius, cyBase + radius * 0.1f);
    glEnd();

    // -------- Simple shading wedges --------
    glColor3f(r * 0.75f, g * 0.75f, b * 0.75f);
    for (int i = 0; i < 8; i++) {
        float a1 = M_PI * i / 8.0f;
        float a2 = M_PI * (i + 1) / 8.0f;
        glBegin(GL_TRIANGLES);
            glVertex2f(cx, cyBase);
            glVertex2f(cx + radius * cosf(a1), cyBase + radius * sinf(a1));
            glVertex2f(cx + radius * cosf(a2), cyBase + radius * sinf(a2));
        glEnd();
    }

    // -------- Decorative golden elements --------
    glColor3f(0.9f, 0.9f, 0.1f);
    for (int i = 0; i < 8; i++) {
        float angle = 2.0f * M_PI * i / 8.0f;
        float x = cx + (radius * 0.6f) * cosf(angle);
        float y = cyBase + radius * 0.3f;
        drawFilledCircle(x, y, 0.15f, 24);
    }

    // -------- Flag --------
    glColor3f(0.0f, 0.6f, 0.2f); // green rectangle
    glBegin(GL_QUADS);
        glVertex2f(0.5f, 2.0f);
        glVertex2f(1.3f, 2.0f);
        glVertex2f(1.3f, 2.6f);
        glVertex2f(0.5f, 2.6f);
    glEnd();
    glColor3f(0.8f, 0.0f, 0.0f); // red circle
    drawFilledCircle(0.9f, 2.3f, 0.18f, 50);
    glColor3f(0.3f, 0.3f, 0.3f); // pole
    glBegin(GL_QUADS);
        glVertex2f(0.46f, 0.0f);
        glVertex2f(0.50f, 0.0f);
        glVertex2f(0.50f, 2.0f);
        glVertex2f(0.46f, 2.0f);
    glEnd();

    // -------- Outlines --------
    glColor3f(r * 0.5f, g * 0.5f, b * 0.5f);
    glBegin(GL_LINE_STRIP);
        for (int i = 0; i <= segments; i++) {
            float angle = M_PI * i / segments;
            glVertex2f(cx + radius * cosf(angle),
                       cyBase + radius * sinf(angle));
        }
    glEnd();
    glBegin(GL_LINE_LOOP);
        glVertex2f(cx - radius, cyBase);
        glVertex2f(cx + radius, cyBase);
        glVertex2f(cx + radius, cyBase + radius * 0.1f);
        glVertex2f(cx - radius, cyBase + radius * 0.1f);
    glEnd();
    //float cx = 0.0f, cyBase = 0.5f, radius = 5.0f;
        //drawTiledDome(0.0f, 0.5f, 5.0f);
}


// Base platform
void drawBasePlatform() {
    float cx = 0.0f, cyBase = 0.0f, width = 20.0f;
    float halfWidth = width / 2.0f;

    glColor3f(nightMode ? 0.6f : 0.8f, nightMode ? 0.6f : 0.8f, nightMode ? 0.55f : 0.75f);
    glBegin(GL_QUADS);
    glVertex2f(cx - halfWidth, cyBase);
    glVertex2f(cx + halfWidth, cyBase);
    glVertex2f(cx + halfWidth, cyBase + 0.5f);
    glVertex2f(cx - halfWidth, cyBase + 0.5f);
    glEnd();

    glColor3f(0.5f, 0.5f, 0.5f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(cx - halfWidth, cyBase);
    glVertex2f(cx + halfWidth, cyBase);
    glVertex2f(cx + halfWidth, cyBase + 0.5f);
    glVertex2f(cx - halfWidth, cyBase + 0.5f);
    glEnd();
}

// Buildings
void drawBuildings() {
    float buildingWidth = 13.0f;
    float buildingHeight = 6.0f;

    // Base color
    float r = nightMode ? 0.1f : 0.15f;
    float g = nightMode ? 0.3f : 0.40f;
    float b = nightMode ? 0.5f : 0.70f;

    // Left building
    glPushMatrix();
    glTranslatef(-19.0f, 0.0f, 0.0f);

    glColor3f(r, g, b);
    glBegin(GL_QUADS);
    glVertex2f(0.0f, 0.0f);
    glVertex2f(buildingWidth, 0.0f);
    glVertex2f(buildingWidth, buildingHeight);
    glVertex2f(0.0f, buildingHeight);
    glEnd();

    // Columns
    float columnWidth = 0.4f;
    glColor3f(nightMode ? 0.6f : 0.8f, nightMode ? 0.6f : 0.8f, nightMode ? 0.6f : 0.8f);
    for (int i = 0; i < 5; i++) {
        float xPos = i * (buildingWidth / 4.0f);
        glBegin(GL_QUADS);
        glVertex2f(xPos, 0.0f);
        glVertex2f(xPos + columnWidth, 0.0f);
        glVertex2f(xPos + columnWidth, buildingHeight);
        glVertex2f(xPos, buildingHeight);
        glEnd();
    }

    // Windows
    float windowWidth = 0.8f;
    float windowHeight = 1.2f;
    glColor3f(0.9f, 0.9f, 1.0f);
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            float xPos = (i + 0.5f) * (buildingWidth / 4.0f) - windowWidth/2;
            float yPos = (j + 0.5f) * (buildingHeight / 4.0f) - windowHeight/2;

            glBegin(GL_QUADS);
            glVertex2f(xPos, yPos);
            glVertex2f(xPos + windowWidth, yPos);
            glVertex2f(xPos + windowWidth, yPos + windowHeight);
            glVertex2f(xPos, yPos + windowHeight);
            glEnd();

            glColor3f(0.3f, 0.3f, 0.3f);
            glBegin(GL_LINE_LOOP);
            glVertex2f(xPos, yPos);
            glVertex2f(xPos + windowWidth, yPos);
            glVertex2f(xPos + windowWidth, yPos + windowHeight);
            glVertex2f(xPos, yPos + windowHeight);
            glEnd();
            glColor3f(0.9f, 0.9f, 1.0f);
        }
    }

    // Roof
    glColor3f(r * 0.7f, g * 0.7f, b * 0.7f);
    glBegin(GL_QUADS);
    glVertex2f(-0.5f, buildingHeight);
    glVertex2f(buildingWidth + 0.5f, buildingHeight);
    glVertex2f(buildingWidth, buildingHeight + 1.0f);
    glVertex2f(0.0f, buildingHeight + 1.0f);
    glEnd();

    glPopMatrix();

    // Right building
    glPushMatrix();
    glTranslatef(6.0f, 0.0f, 0.0f);

    glColor3f(r, g, b);
    glBegin(GL_QUADS);
    glVertex2f(0.0f, 0.0f);
    glVertex2f(buildingWidth, 0.0f);
    glVertex2f(buildingWidth, buildingHeight);
    glVertex2f(0.0f, buildingHeight);
    glEnd();

    // Columns
    glColor3f(nightMode ? 0.6f : 0.8f, nightMode ? 0.6f : 0.8f, nightMode ? 0.6f : 0.8f);
    for (int i = 0; i < 5; i++) {
        float xPos = i * (buildingWidth / 4.0f);
        glBegin(GL_QUADS);
        glVertex2f(xPos, 0.0f);
        glVertex2f(xPos + columnWidth, 0.0f);
        glVertex2f(xPos + columnWidth, buildingHeight);
        glVertex2f(xPos, buildingHeight);
        glEnd();
    }

    // Windows
    glColor3f(0.9f, 0.9f, 1.0f);
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            float xPos = (i + 0.5f) * (buildingWidth / 4.0f) - windowWidth/2;
            float yPos = (j + 0.5f) * (buildingHeight / 4.0f) - windowHeight/2;

            glBegin(GL_QUADS);
            glVertex2f(xPos, yPos);
            glVertex2f(xPos + windowWidth, yPos);
            glVertex2f(xPos + windowWidth, yPos + windowHeight);
            glVertex2f(xPos, yPos + windowHeight);
            glEnd();

            glColor3f(0.3f, 0.3f, 0.3f);
            glBegin(GL_LINE_LOOP);
            glVertex2f(xPos, yPos);
            glVertex2f(xPos + windowWidth, yPos);
            glVertex2f(xPos + windowWidth, yPos + windowHeight);
            glVertex2f(xPos, yPos + windowHeight);
            glEnd();
            glColor3f(0.9f, 0.9f, 1.0f);
        }
    }

    // Roof
    glColor3f(r * 0.7f, g * 0.7f, b * 0.7f);
    glBegin(GL_QUADS);
    glVertex2f(-0.5f, buildingHeight);
    glVertex2f(buildingWidth + 0.5f, buildingHeight);
    glVertex2f(buildingWidth, buildingHeight + 1.0f);
    glVertex2f(0.0f, buildingHeight + 1.0f);
    glEnd();

    glPopMatrix();
}

// Grass
void drawGrass() {
    glColor3f(nightMode ? 0.2f : 0.3f, nightMode ? 0.3f : 0.5f, nightMode ? 0.1f : 0.2f);
    glBegin(GL_QUADS);
    glVertex2f(-20.0f, -2.0f);
    glVertex2f(20.0f, -2.0f);
    glVertex2f(20.0f, 0.5f);
    glVertex2f(-20.0f, 0.5f);
    glEnd();

    // Simple grass details
    glColor3f(nightMode ? 0.1f : 0.2f, nightMode ? 0.4f : 0.6f, nightMode ? 0.1f : 0.2f);
    glBegin(GL_LINES);
    for (int i = 0; i < 50; i++) {
        float x = -19.0f + (i % 38);
        float y = -1.8f + (i % 3) * 0.1f;
        glVertex2f(x, y);
        glVertex2f(x + 0.1f, y + 0.1f);
    }
    glEnd();
}

// Trees
void drawTrees() {
    float treePositions[] = {-18.0f, -14.0f, -10.0f, 10.0f, 14.0f, 18.0f};

    for (int t = 0; t < 6; t++) {
        float x = treePositions[t];

        // Trunk
        glColor3f(nightMode ? 0.3f : 0.4f, nightMode ? 0.15f : 0.2f, nightMode ? 0.05f : 0.1f);
        glBegin(GL_QUADS);
        glVertex2f(x - 0.2f, 0.0f);
        glVertex2f(x + 0.2f, 0.0f);
        glVertex2f(x + 0.2f, 1.5f);
        glVertex2f(x - 0.2f, 1.5f);
        glEnd();

        // Leaves (simple circles)
        glColor3f(nightMode ? 0.0f : 0.0f, nightMode ? 0.4f : 0.6f, nightMode ? 0.0f : 0.0f);
        drawFilledCircle(x, 2.2f, 0.8f, 20);
        drawFilledCircle(x, 2.9f, 0.6f, 20);
        drawFilledCircle(x, 3.4f, 0.4f, 20);
    }
}

// Road
void drawRoad() {
    // Main road
    glColor3f(nightMode ? 0.15f : 0.25f, nightMode ? 0.15f : 0.25f, nightMode ? 0.15f : 0.25f);
    glBegin(GL_QUADS);
    glVertex2f(-20.0f, -20.0f);
    glVertex2f(0.0f, -2.0f);
    glVertex2f(0.0f, -0.5f);
    glVertex2f(-20.0f, -0.5f);
    glEnd();

    glBegin(GL_QUADS);
    glVertex2f(0.0f, -2.0f);
    glVertex2f(20.0f, -10.0f);
    glVertex2f(20.0f, -0.5f);
    glVertex2f(0.0f, -0.5f);
    glEnd();

    // Road markings
    glColor3f(nightMode ? 0.7f : 1.0f, nightMode ? 0.7f : 1.0f, nightMode ? 0.0f : 0.0f);
    for (int i = 0; i < 40; i++) {
        float x = -19.5f + i;
        glBegin(GL_QUADS);
        glVertex2f(x, -1.3f);
        glVertex2f(x + 0.5f, -1.3f);
        glVertex2f(x + 0.5f, -1.2f);
        glVertex2f(x, -1.2f);
        glEnd();
    }

    // Sidewalk
    glColor3f(nightMode ? 0.4f : 0.6f, nightMode ? 0.4f : 0.6f, nightMode ? 0.4f : 0.6f);
    glBegin(GL_QUADS);
    glVertex2f(-20.0f, -2.5f);
    glVertex2f(20.0f, -2.5f);
    glVertex2f(20.0f, -2.0f);
    glVertex2f(-20.0f, -2.0f);
    glEnd();
}

// Traffic signal
void drawTrafficSignal() {
    // Pillar
    glColor3f(0.3f, 0.3f, 0.3f);
    glBegin(GL_QUADS);
    glVertex2f(-2.2f, -2.5f);
    glVertex2f(-2.0f, -2.5f);
    glVertex2f(-2.0f, 0.0f);
    glVertex2f(-2.2f, 0.0f);
    glEnd();

    // Signal box
    glColor3f(0.5f, 0.5f, 0.5f);
    glBegin(GL_QUADS);
    glVertex2f(-2.0f, 0.0f);
    glVertex2f(-1.8f, 0.0f);
    glVertex2f(-1.8f, 1.0f);
    glVertex2f(-2.0f, 1.0f);
    glEnd();

    // Red light
    glColor3f((trafficLight == RED) ? 1.0f : 0.3f, 0.0f, 0.0f);
    drawFilledCircle(-1.9f, 0.8f, 0.08f, 20);
    glColor3f(0.3f, 0.3f, 0.3f);
    drawCircleOutline(-1.9f, 0.8f, 0.08f, 20);

    // Yellow light
    glColor3f((trafficLight == YELLOW) ? 1.0f : 0.3f, (trafficLight == YELLOW) ? 1.0f : 0.3f, 0.0f);
    drawFilledCircle(-1.9f, 0.7f, 0.08f, 20);
    glColor3f(0.3f, 0.3f, 0.3f);
    drawCircleOutline(-1.9f, 0.7f, 0.08f, 20);

    // Green light
    glColor3f(0.0f, (trafficLight == GREEN) ? 1.0f : 0.3f, 0.0f);
    drawFilledCircle(-1.9f, 0.6f, 0.08f, 20);
    glColor3f(0.3f, 0.3f, 0.3f);
    drawCircleOutline(-1.9f, 0.6f, 0.08f, 20);
}

// Car
void drawCar(float posX, int type) {
    glPushMatrix();
    glTranslatef(posX, -1.25f, 0.0f);

    if (type == 0) { // Sedan
        // Body
        glColor3f(nightMode ? 0.6f : 0.8f, nightMode ? 0.15f : 0.2f, nightMode ? 0.15f : 0.2f);
        glBegin(GL_QUADS);
        glVertex2f(-0.8f, -0.3f);
        glVertex2f(0.8f, -0.3f);
        glVertex2f(0.8f, 0.9f);
        glVertex2f(-0.8f, 0.9f);
        glEnd();

        // Top
        glColor3f(nightMode ? 0.5f : 0.7f, nightMode ? 0.1f : 0.15f, nightMode ? 0.1f : 0.15f);
        glBegin(GL_QUADS);
        glVertex2f(-0.6f, 0.1f);
        glVertex2f(0.6f, 0.1f);
        glVertex2f(0.6f, 0.9f);
        glVertex2f(-0.6f, 0.9f);
        glEnd();

        // Windshield
        glColor3f(0.7f, 0.9f, 1.0f);
        glBegin(GL_QUADS);
        glVertex2f(-0.6f, 0.1f);
        glVertex2f(0.6f, 0.1f);
        glVertex2f(0.6f, 0.3f);
        glVertex2f(-0.6f, 0.3f);
        glEnd();

    } else if (type == 1) { // Truck
        // Body
        glColor3f(nightMode ? 0.4f : 0.6f, nightMode ? 0.3f : 0.4f, nightMode ? 0.2f : 0.3f);
        glBegin(GL_QUADS);
        glVertex2f(-1.0f, -0.4f);
        glVertex2f(1.0f, -0.4f);
        glVertex2f(1.0f, 0.8f);
        glVertex2f(-1.0f, 0.8f);
        glEnd();

        // Cabin
        glColor3f(nightMode ? 0.3f : 0.5f, nightMode ? 0.2f : 0.3f, nightMode ? 0.1f : 0.2f);
        glBegin(GL_QUADS);
        glVertex2f(-1.0f, 0.0f);
        glVertex2f(-0.5f, 0.0f);
        glVertex2f(-0.5f, 0.8f);
        glVertex2f(-1.0f, 0.8f);
        glEnd();

    } else if (type == 2) { // Van
        // Body
        glColor3f(nightMode ? 0.7f : 0.9f, nightMode ? 0.2f : 0.3f, nightMode ? 0.2f : 0.3f);
        glBegin(GL_QUADS);
        glVertex2f(-0.9f, -0.3f);
        glVertex2f(0.9f, -0.3f);
        glVertex2f(0.9f, 1.0f);
        glVertex2f(-0.9f, 1.0f);
        glEnd();

        // Windshield
        glColor3f(0.7f, 0.9f, 1.0f);
        glBegin(GL_QUADS);
        glVertex2f(-0.7f, 0.1f);
        glVertex2f(0.7f, 0.1f);
        glVertex2f(0.7f, 0.4f);
        glVertex2f(-0.7f, 0.4f);
        glEnd();
    }

    // Wheels
    glColor3f(nightMode ? 0.05f : 0.1f, nightMode ? 0.05f : 0.1f, nightMode ? 0.05f : 0.1f);
    drawFilledCircle(-0.5f, -0.3f, 0.15f, 20);
    drawFilledCircle(0.5f, -0.3f, 0.15f, 20);

    glColor3f(0.5f, 0.5f, 0.5f);
    drawFilledCircle(-0.5f, -0.3f, 0.08f, 20);
    drawFilledCircle(0.5f, -0.3f, 0.08f, 20);

    if (type == 1) { // Extra wheel for truck
        glColor3f(nightMode ? 0.05f : 0.1f, nightMode ? 0.05f : 0.1f, nightMode ? 0.05f : 0.1f);
        drawFilledCircle(0.3f, -0.3f, 0.15f, 20);
        glColor3f(0.5f, 0.5f, 0.5f);
        drawFilledCircle(0.3f, -0.3f, 0.08f, 20);
    }

    glPopMatrix();
}

// Sun/Moon
void drawSunOrMoon() {
    float x = 10.0f * cosf(sunAngle * M_PI/180.0f);
    float y = 15.0f;

    if (nightMode) {
        // Moon
        glColor3f(0.9f, 0.9f, 0.9f);
        drawFilledCircle(x, y, 1.5f, 30);

        // Moon craters
        glColor3f(0.7f, 0.7f, 0.7f);
        drawFilledCircle(x - 0.5f, y + 0.5f, 0.3f, 15);
        drawFilledCircle(x + 0.5f, y - 0.5f, 0.4f, 15);
        drawFilledCircle(x + 0.3f, y + 0.6f, 0.2f, 10);
    } else {
        // Sun
        glColor3f(1.0f, 0.9f, 0.1f);
        drawFilledCircle(x, y, 1.5f, 30);

        // Sun rays
        glBegin(GL_LINES);
        for (int i = 0; i < 12; i++) {
            float angle = 2.0f * M_PI * i / 12.0f;
            glVertex2f(x + 1.5f * cosf(angle), y + 1.5f * sinf(angle));
            glVertex2f(x + 2.5f * cosf(angle), y + 2.5f * sinf(angle));
        }
        glEnd();
    }
}

// Stars (simplified - no arrays)
void drawStars() {
    if (!nightMode) return;

    glColor3f(1.0f, 1.0f, 1.0f);
    glPointSize(2.0f);
    glBegin(GL_POINTS);
    // Fixed star positions
    glVertex2f(-18.0f, 16.0f);
    glVertex2f(-15.0f, 18.0f);
    glVertex2f(-12.0f, 17.0f);
    glVertex2f(-8.0f, 19.0f);
    glVertex2f(-5.0f, 16.0f);
    glVertex2f(-2.0f, 18.5f);
    glVertex2f(2.0f, 17.0f);
    glVertex2f(5.0f, 19.0f);
    glVertex2f(8.0f, 16.5f);
    glVertex2f(12.0f, 18.0f);
    glVertex2f(15.0f, 17.5f);
    glVertex2f(18.0f, 19.0f);
    glVertex2f(-16.0f, 14.0f);
    glVertex2f(-10.0f, 15.0f);
    glVertex2f(-6.0f, 14.5f);
    glVertex2f(0.0f, 15.5f);
    glVertex2f(6.0f, 14.0f);
    glVertex2f(10.0f, 15.5f);
    glVertex2f(16.0f, 14.5f);
    glVertex2f(-14.0f, 12.0f);
    glVertex2f(-7.0f, 13.0f);
    glVertex2f(3.0f, 12.5f);
    glVertex2f(9.0f, 13.5f);
    glVertex2f(14.0f, 12.0f);
    glEnd();
}

// Clouds
void drawClouds() {
    glColor3f(nightMode ? 0.7f : 0.95f, nightMode ? 0.7f : 0.95f, nightMode ? 0.7f : 0.95f);

    for (int i = 0; i < 4; i++) {
        float x = -20.0f + i * 12.0f + fmodf(cloudPosX, 40.0f);
        if (x > 20.0f) x -= 40.0f;
        float y = 14.0f + (i % 2);
        float size = 1.5f + (i % 2) * 0.5f;

        drawFilledCircle(x, y, size, 20);
        drawFilledCircle(x + size * 0.8f, y - size * 0.2f, size * 0.7f, 15);
        drawFilledCircle(x + size * 1.4f, y + size * 0.1f, size * 0.6f, 15);
    }
}

// Simple rain effect
void drawRain() {
    if (!rainMode) return;

    glColor3f(0.6f, 0.6f, 1.0f);
    glLineWidth(1.0f);
    glBegin(GL_LINES);

    // Simple rain drops at fixed positions
    for (int i = 0; i < 50; i++) {
        float x = -20.0f + i * 0.8f;
        float y = 20.0f - fmodf(rainTimer * 10.0f + i * 0.5f, 25.0f);
        glVertex2f(x, y);
        glVertex2f(x - 0.2f, y - 1.0f);
    }
    glEnd();
}

// Person - simplified version without arrays
void drawPerson(float x, float y, float legAngleDeg) {
    glPushMatrix();
    glTranslatef(x, y, 0.0f);

    // Head
    glColor3f(0.99f, 0.91f, 0.68f);
    drawFilledCircle(0.0f, 0.5f, 0.1f, 20);

    // Hair
    glColor3f(0.0f, 0.0f, 0.0f);
    glBegin(GL_TRIANGLES);
    glVertex2f(-0.08f, 0.48f);
    glVertex2f(0.08f, 0.55f);
    glVertex2f(0.0f, 0.48f);
    glEnd();

    // Eyes
    glColor3f(0.0f, 0.0f, 0.0f);
    drawFilledCircle(-0.03f, 0.53f, 0.01f, 10);
    drawFilledCircle(0.03f, 0.53f, 0.01f, 10);

    // Mouth
    glBegin(GL_LINES);
    glVertex2f(-0.02f, 0.48f);
    glVertex2f(0.02f, 0.48f);
    glEnd();

    // Neck
    glColor3f(0.99f, 0.91f, 0.68f);
    glBegin(GL_QUADS);
    glVertex2f(-0.02f, 0.43f);
    glVertex2f(0.02f, 0.43f);
    glVertex2f(0.02f, 0.35f);
    glVertex2f(-0.02f, 0.35f);
    glEnd();

    // Body
    glColor3f(0.35f, 0.04f, 0.6f);
    glBegin(GL_QUADS);
    glVertex2f(-0.05f, 0.35f);
    glVertex2f(0.05f, 0.35f);
    glVertex2f(0.05f, 0.0f);
    glVertex2f(-0.05f, 0.0f);
    glEnd();

    // Arms
    glBegin(GL_QUADS);
    glVertex2f(-0.05f, 0.25f);
    glVertex2f(-0.08f, 0.25f);
    glVertex2f(-0.08f, 0.15f);
    glVertex2f(-0.05f, 0.15f);

    glVertex2f(0.05f, 0.25f);
    glVertex2f(0.08f, 0.25f);
    glVertex2f(0.08f, 0.15f);
    glVertex2f(0.05f, 0.15f);
    glEnd();

    // Legs with animation
    glColor3f(0.0f, 0.0f, 0.0f);

    glPushMatrix();
    glTranslatef(-0.03f, 0.0f, 0.0f);
    glRotatef(legAngleDeg, 0.0f, 0.0f, 1.0f);
    glBegin(GL_QUADS);
    glVertex2f(-0.02f, 0.0f);
    glVertex2f(0.02f, 0.0f);
    glVertex2f(0.02f, -0.3f);
    glVertex2f(-0.02f, -0.3f);
    glEnd();
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.03f, 0.0f, 0.0f);
    glRotatef(-legAngleDeg, 0.0f, 0.0f, 1.0f);
    glBegin(GL_QUADS);
    glVertex2f(-0.02f, 0.0f);
    glVertex2f(0.02f, 0.0f);
    glVertex2f(0.02f, -0.3f);
    glVertex2f(-0.02f, -0.3f);
    glEnd();
    glPopMatrix();

    glPopMatrix();
}

// Update people positions
void updatePeople() {
    // Person 1
    person1X += person1Dir * person1Speed;
    person1LegAngle += person1LegSwing * 1.0f;
    if (person1LegAngle > 30.0f || person1LegAngle < -30.0f) person1LegSwing *= -1;
    if (person1X < -20.0f || person1X > 20.0f) person1Dir *= -1;

    // Person 2
    person2X += person2Dir * person2Speed;
    person2LegAngle += person2LegSwing * 1.0f;
    if (person2LegAngle > 30.0f || person2LegAngle < -30.0f) person2LegSwing *= -1;
    if (person2X < -20.0f || person2X > 20.0f) person2Dir *= -1;

    // Person 3
    person3X += person3Dir * person3Speed;
    person3LegAngle += person3LegSwing * 1.0f;
    if (person3LegAngle > 30.0f || person3LegAngle < -30.0f) person3LegSwing *= -1;
    if (person3X < -20.0f || person3X > 20.0f) person3Dir *= -1;

    // Person 4
    person4X += person4Dir * person4Speed;
    person4LegAngle += person4LegSwing * 1.0f;
    if (person4LegAngle > 30.0f || person4LegAngle < -30.0f) person4LegSwing *= -1;
    if (person4X < -20.0f || person4X > 20.0f) person4Dir *= -1;

    // Person 5
    person5X += person5Dir * person5Speed;
    person5LegAngle += person5LegSwing * 1.0f;
    if (person5LegAngle > 30.0f || person5LegAngle < -30.0f) person5LegSwing *= -1;
    if (person5X < -20.0f || person5X > 20.0f) person5Dir *= -1;
}

void Scene_C() {
    if (nightMode) {
        glClearColor(0.05f, 0.05f, 0.15f, 1.0f);
    } else if (rainMode) {
        glClearColor(0.3f, 0.5f, 0.7f, 1.0f);
    } else {
        glClearColor(0.5f, 0.8f, 0.92f, 1.0f);
    }

    glClear(GL_COLOR_BUFFER_BIT);
    glLoadIdentity();

    drawStars();
    drawSunOrMoon();
    drawClouds();

    drawGrass();
    drawRoad();
    drawBasePlatform();
    drawNovoTheatreDome();
    //drawTiledDome(0.0f, 0.5f, 5.0f);
    drawBuildings();
    drawTrees();
    drawTrafficSignal();

    // Cars with traffic light logic
    float currentSpeed;

    // Car 1 (Sedan, right lane → +X)
    if (trafficLight == RED && car1PosX >= leftLaneStop - STOP_DISTANCE && car1PosX <= leftLaneStop)
        currentSpeed = 0.0f;
    else if (trafficLight == YELLOW)
        currentSpeed = car1Speed * 0.5f;
    else
        currentSpeed = car1Speed;

    car1PosX += currentSpeed;
    if (car1PosX > 20.0f) car1PosX = -20.0f;
    drawCar(car1PosX, 0);

    // Car 2 (Truck, left lane ← -X)
    if (trafficLight == RED && car2PosX >= rightLaneStop && car2PosX <= rightLaneStop + STOP_DISTANCE)
        currentSpeed = 0.0f;
    else if (trafficLight == YELLOW)
        currentSpeed = car2Speed * 0.5f;
    else
        currentSpeed = car2Speed;

    car2PosX -= currentSpeed;
    if (car2PosX < -20.0f) car2PosX = 20.0f;
    drawCar(car2PosX, 1);

    // Car 3 (Van, right lane → +X)
    if (trafficLight == RED && car3PosX >= leftLaneStop - STOP_DISTANCE && car3PosX <= leftLaneStop)
        currentSpeed = 0.0f;
    else if (trafficLight == YELLOW)
        currentSpeed = car3Speed * 0.5f;
    else
        currentSpeed = car3Speed;

    car3PosX += currentSpeed;
    if (car3PosX > 20.0f) car3PosX = -20.0f;
    drawCar(car3PosX, 2);

    // Car 4 (Sedan, left lane ← -X)
    if (trafficLight == RED && car4PosX >= rightLaneStop && car4PosX <= rightLaneStop + STOP_DISTANCE)
        currentSpeed = 0.0f;
    else if (trafficLight == YELLOW)
        currentSpeed = car4Speed * 0.5f;
    else
        currentSpeed = car4Speed;

    car4PosX -= currentSpeed;
    if (car4PosX < -20.0f) car4PosX = 20.0f;
    drawCar(car4PosX, 0);

    // Car 5 (Truck, right lane → +X)
    if (trafficLight == RED && car5PosX >= leftLaneStop - STOP_DISTANCE && car5PosX <= leftLaneStop)
        currentSpeed = 0.0f;
    else if (trafficLight == YELLOW)
        currentSpeed = car5Speed * 0.5f;
    else
        currentSpeed = car5Speed;

    car5PosX += currentSpeed;
    if (car5PosX > 20.0f) car5PosX = -20.0f;
    drawCar(car5PosX, 1);

    // Car 6 (Van, left lane ← -X)
    if (trafficLight == RED && car6PosX >= rightLaneStop && car6PosX <= rightLaneStop + STOP_DISTANCE)
        currentSpeed = 0.0f;
    else if (trafficLight == YELLOW)
        currentSpeed = car6Speed * 0.5f;
    else
        currentSpeed = car6Speed;

    car6PosX -= currentSpeed;
    if (car6PosX < -20.0f) car6PosX = 20.0f;
    drawCar(car6PosX, 2);

    // Draw people
    drawPerson(person1X, person1Y, person1LegAngle);
    drawPerson(person2X, person2Y, person2LegAngle);
    drawPerson(person3X, person3Y, person3LegAngle);
    drawPerson(person4X, person4Y, person4LegAngle);
    drawPerson(person5X, person5Y, person5LegAngle);

    // Rain overlay
    drawRain();

    //glutSwapBuffers();
}
void Scene_c(){
    //glClearColor(0.5f, 0.8f, 0.92f, 1.0f);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-20.0, 20.0, -5.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    Scene_C();

}

void update(int /*value*/) {
    cloudPosX += cloudSpeed;
    rainTimer += 0.016f;
    sunAngle += 0.1f;
    if (sunAngle > 90.0f) sunAngle = 45.0f;
/*
    trafficTimer += 0.016f;
    if (trafficTimer >= TRAFFIC_INTERVAL * 3) {
        trafficTimer = 0.0f;
    }

    // Simple traffic light cycle
    if (trafficTimer < TRAFFIC_INTERVAL) {
        trafficLight = GREEN;
    } else if (trafficTimer < TRAFFIC_INTERVAL * 2) {
        trafficLight = YELLOW;
    } else {
        trafficLight = RED;
    }
*/
    updatePeople();

    glutPostRedisplay();
    glutTimerFunc(16, update, 0);
}

//Scenario D---------------------------------------------------------------------------------------------------------------------------
//General Quad
void drawQuad_D(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float r, float g, float b)
{
    glColor3f(r,g,b);
    glBegin(GL_QUADS);
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);
    glVertex2f(x3, y3);
    glVertex2f(x4, y4);
    glEnd();
}

//General circle function
void Circle_D(float radius, float xc, float yc, float r, float g, float b)
{
    glBegin(GL_POLYGON);
    for(int i=0; i<200; i++)
    {
        glColor3f(r,g,b);
        float pi=3.1416;
        float A=(i*2*pi)/200;
        float r=radius;
        float x = r * cos(A);
        float y = r * sin(A);
        glVertex2f(x+xc,y+yc);
    }
    glEnd();
}

//General SemiCircle function
void SemiCircle_D(float radius, float xc, float yc, float r, float g, float b)
{
    glBegin(GL_POLYGON);
    for(int i=0; i<200; i++)
    {
        glColor3f(r,g,b);
        float pi=3.1416;
        float A=(i*2*pi)/400;
        float r=radius;
        float x = r * cos(A);
        float y = r * sin(A);
        glVertex2f(x+xc,y+yc);
    }
    glEnd();
}

//General Line Draw
void Line_D(float x1, float y1, float x2, float y2,float r, float g, float b)
{
    glColor3f(r,g,b);
    glLineWidth(2);
    glBegin(GL_LINES);
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);
    glEnd();
}
// Generate random X coordinate between -40 and 40
static inline float randX_D()
{
    return -40.0f + 80.0f * (rand() / (float)RAND_MAX);
}
// Add a single raindrop
void addDrop_D()
{
    if (totalDrops_D < MAX_DROPS)
    {
        dropX_D[totalDrops_D] = randX_D();
        dropY_D[totalDrops_D] = 20.0f;  // start from top of ortho
        totalDrops_D++;
    }
}
// Draw all raindrops
void drawRaindrops_D()
{
    glColor3f(0.043f, 0.435f, 0.639f);
    glBegin(GL_LINES);
    for (int i = 0; i < totalDrops_D; ++i)
    {
        glVertex2f(dropX_D[i], dropY_D[i]);
        glVertex2f(dropX_D[i], dropY_D[i] - 0.3f);  // length of drop
    }
    glEnd();
}
void drawRotatingWheel_D(float cx, float cy, float radius, float angle)
{
    glPushMatrix();
    glTranslatef(cx, cy, 0.0f);    // move to wheel center
    glRotatef(angle, 0, 0, 1);     // rotate around center

    // Wheel outer circle
    Circle_D(radius, 0, 0, 0.5, 0.5, 0.5);
    // Inner hub
    Circle_D(radius * 0.6, 0, 0, 0, 0, 0);

    // Simple spokes
    glColor3f(1.0f, 1.0f, 1.0f);
    glBegin(GL_LINES);
    glVertex2f(0, 0);
    glVertex2f(radius * 0.6, 0);
    glVertex2f(0, 0);
    glVertex2f(-radius * 0.6, 0);
    glVertex2f(0, 0);
    glVertex2f(0, radius * 0.6);
    glVertex2f(0, 0);
    glVertex2f(0, -radius * 0.6);
    glEnd();

    glPopMatrix();
}
//Text writing

//RBB
struct RGB_D
{
    int red;
    int green;
    int blue;
};

//Polygon
void polygon_D(std::vector<std::pair<float, float>> coord, RGB_D rgb = {255, 255, 255},
               float Tx = 0, float Ty = 0, float s = 1)
{
    glColor3ub(rgb.red, rgb.green, rgb.blue);
    glBegin(GL_POLYGON);
    for (auto& c : coord)
        glVertex2f(Tx + s * c.first, Ty + s * c.second);
    glEnd();
}

//Bird Drawing
void bird_D(float Tx, float Ty, float direction, float birdWingY, float s = 0.3f, RGB_D rgb = {0,0,0})
{
    // Body
    polygon_D(
    {
        {5.0f * direction, 0.5f},{6.0f * direction, 0.3f},{5.9f * direction, 0.05f},{5.95f * direction, -0.25f},
        {5.3f * direction, -0.07f},{5.0f * direction, -0.22f},{4.2f * direction, -0.95f},{2.8f * direction, -1.1f},
        {1.8f * direction, -1.0f},{0.5f * direction, -2.0f},{1.7f * direction, -0.6f},{0.05f * direction, 0.25f},
        {1.9f * direction, -0.06f},{2.2f * direction, 0.05f},{4.5f * direction, 0.37f},{5.0f * direction, 0.5f}
    }, rgb, Tx, Ty, s);

    // Wing
    polygon_D(
    {
        {4.5f * direction, birdWingY * 0.37f},
        {4.7f * direction, birdWingY * 1.7f},
        {2.0f * direction, birdWingY * 5.0f},
        {2.2f * direction, birdWingY * 0.05f}
    }, rgb, Tx, Ty, s);
}

//Bird Display
void birdDisplay_D()
{
    bird_D(birdX1_D, birdY1_D, birdDirection1_D, birdWingY1_D, 0.3f);
    bird_D(birdX2_D, birdY2_D, birdDirection2_D, birdWingY2_D, birdScale2_D);
    bird_D(birdX3_D, birdY3_D, birdDirection3_D, birdWingY3_D, birdScale3_D);
}


//***************************SKY****************************//
void Cloud_D_1(float x, float y, float scale, float r, float g, float b)
{
    glPushMatrix();
    glTranslated(x,y,0.0);
    glScalef(scale, scale, 1.0f);

    SemiCircle_D(3,-21,14,r,g,b);
    SemiCircle_D(4.5,-16,14,r,g,b);
    SemiCircle_D(3,-11,14,r,g,b);

    glPopMatrix();
}
void Cloud_D_2(float x, float y, float scale,float r, float g, float b)
{
    glPushMatrix();
    glTranslated(x,y,0.0);
    glScalef(scale, scale, 1.0f);

    Circle_D(2,-36,16,r,g,b);
    Circle_D(2,-31,16,r,g,b);
    Circle_D(2.5,-33.5,16.5,r,g,b);
    Circle_D(2.5,-33.5,15.5,r,g,b);

    glPopMatrix();
}
void Moon_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    //full
    Circle_D(3,18,14,0.812, 0.812, 0.812);

    //inner
    Circle_D(0.7,19.5,14,0.69f, 0.69f, 0.69f);
    Circle_D(0.4,17.5,13,0.69f, 0.69f, 0.69f);
    Circle_D(0.6,16,15,0.69f, 0.69f, 0.69f);
    Circle_D(0.4,19,12,0.69f, 0.69f, 0.69f);
    Circle_D(0.5,18,16,0.69f, 0.69f, 0.69f);

    glPopMatrix();
}
void Sun_D(float x, float y, float r, float g, float b, float scale)
{
    glPushMatrix();
    glTranslated(x, y, 0.0);
    glScaled(scale, scale, 1);

    // Draw the sun core (circle)
    Circle_D(3.5, 32, 14,r,g,b);

    // Draw rays
    glColor3f(r,g,b);  // same as sun color
    glLineWidth(2);
    glBegin(GL_LINES);
    int rays = 16;  // number of rays
    float pi = 3.1416;
    for (int i = 0; i < rays; i++)
    {
        float A = (2 * pi * i) / rays;  // evenly spaced angles
        float x1 = 32+4.2f * cos(A);       // start just outside the circle
        float y1 = 14+4.2f * sin(A);
        float x2 = 32+5.5f * cos(A);       // end further away (ray length)
        float y2 = 14+5.5f * sin(A);
        glVertex2f(x1, y1);
        glVertex2f(x2, y2);
    }
    glEnd();
}
void drawGradient_D(float left, float right, float bottom, float top,
                    float rTop, float gTop, float bTop,
                    float rBottom, float gBottom, float bBottom)
{
    glBegin(GL_QUADS);
    // bottom color
    glColor3f(rBottom, gBottom, bBottom);
    glVertex2f(left, bottom);
    glVertex2f(right, bottom);

    // top color
    glColor3f(rTop, gTop, bTop);
    glVertex2f(right, top);
    glVertex2f(left, top);
    glEnd();
}

void Sky_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    if (isNight_D)
    {
        drawGradient_D(-40, 40, 5, 20,
                       0.05f, 0.05f, 0.2f,   // top
                       0.0f, 0.0f, 0.0f);    // bottom
    }
    else if (isEvening_D)
    {
        drawGradient_D(-40, 40, 5, 20,
                       0.6f, 0.2f, 0.3f,     // top
                       0.9f, 0.5f, 0.3f);    // bottom
    }
    else // Day
    {
        drawGradient_D(-40, 40, 5, 20,
                       0.2f, 0.6f, 1.0f,
                       0.6f, 0.9f, 1.0f);
    }
    // Sun / Moon
    if (!raining_D)
    {
        if (isNight_D)
            Moon_D(0,0);
        else if (isEvening_D)
            Sun_D(0,-1, 0.8f, 0.2f, 0.1f, 0.8);
        else
            Sun_D(-55,3, 1.0f, 0.843f, 0.0f, 0.8);
    }

    //Clouds
    if (isNight_D)
    {
        Cloud_D_1(cloud_D_1PosX_D-40,1,1, 0.7,0.7,0.7);
        Cloud_D_1(cloud_D_1PosX_D-20,-1, 0.6, 0.7,0.7,0.7);
        Cloud_D_2(cloud_D_2PosX_D+30,-5, 1,0.7,0.7,0.7);
        Cloud_D_2(cloud_D_2PosX_D,5, 0.7,0.7,0.7,0.7);
    }
    else if (isEvening_D)
    {
        Cloud_D_1(cloud_D_1PosX_D-40,7, 1, 0.95f, 0.6f, 0.4f);
        Cloud_D_1(cloud_D_1PosX_D-20,4, 0.6, 0.95f, 0.6f, 0.4f);
        Cloud_D_2(cloud_D_2PosX_D+30,-5, 1,0.95f, 0.6f, 0.4f);
        Cloud_D_2(cloud_D_2PosX_D,5, 0.7,0.95f, 0.6f, 0.4f);
    }

    else if (raining_D)
    {
        Cloud_D_1(cloud_D_1PosX_D-40,1,1, 0.7,0.7,0.7);
        Cloud_D_1(cloud_D_1PosX_D-20,-1, 0.6, 0.7,0.7,0.7);
        Cloud_D_2(cloud_D_2PosX_D+30,-5, 1,0.7,0.7,0.7);
        Cloud_D_2(cloud_D_2PosX_D,5, 0.7,0.7,0.7,0.7);
    }
    else
    {
        Cloud_D_1(cloud_D_1PosX_D-40,1,1, 1,1,1);
        Cloud_D_1(cloud_D_1PosX_D-20,-1, 0.6, 1,1,1);
        Cloud_D_2(cloud_D_2PosX_D+30,-5, 1,1,1,1);
        Cloud_D_2(cloud_D_2PosX_D,5, 0.7,1,1,1);
    }

    glPopMatrix();
}
// ************************BRIDGE******************************* //
void Bridge_Structure_D_Func(float a, float b, float c, float d)
{
    glColor3f(0.8, 0.8, 0.8);
    glLineWidth(10.0f);
    // Known endpoints
    float x1 = a, y1 = b;  // left end
    float x2 =  c, y2 = d;  // right end

    // Circle properties
    float centerX = (x1 + x2) / 2.0f;      // midpoint = circle center (X)
    float centerY = (y1 + y2) / 2.0f;      // midpoint (Y) = 0 here
    float radius  = fabs(x2 - x1) / 2.0f;  // half the distance = radius

    int segments = 200; // smoothness

    glBegin(GL_LINE_STRIP);
    for (int i = 0; i <= segments; i++)
    {
        float theta = M_PI * i / segments;
        float x = centerX + radius * cos(theta);
        float y = centerY + radius * sin(theta);
        glVertex2f(x, y);
    }
    glEnd();

}
void Car_D(float x, float y,float r, float g, float b, float mirror, float wheelSpeed)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    //Body
    drawQuad_D(-8,-1, -8,-2, -2.5, -2, -2.5, -1, r,g,b);
    //Mirror
    drawQuad_D(-6.8, -0.2,-7.6,-1.1,-3.5,-1.1, -4.5,-0.2,0,0,0);

    //Frame
    glLineWidth(2.50f);
    glBegin(GL_LINE_LOOP);
    glColor3f(r,g,b);
    glVertex2f(-5.8, -0.2);
    glVertex2f(-5.8, -1.1);
    glVertex2f(-5.8, -1.1);
    glVertex2f(-3.5, -1.1);
    glVertex2f(-3.5, -1.1);
    glVertex2f(-4.5, -0.2);
    glVertex2f(-4.5, -0.2);
    glVertex2f(-6.8, -0.2);
    glVertex2f(-6.8, -0.2);
    glVertex2f(-7.6, -1.1);
    glVertex2f(-5.8, -1.1);
    glEnd();

    if (isNight_D)
    {
        //Light
        glBegin(GL_TRIANGLES);
        glColor3f(1.0f, 1.0f, 0.5f);
        glVertex2f(-0.5, -1);
        glVertex2f(-2.5, -1.5);
        glVertex2f(-0.5, -2);
        glEnd();
    }

    //wheel 1
    drawRotatingWheel_D(-7,-2, 0.5f, carWheelAngle_D);
    //wheel 2
    drawRotatingWheel_D(-3.5,-2, 0.5f, carWheelAngle_D);

    glPopMatrix();
}

void Car2_D(float x, float y, float r, float g, float b, float mirror)
{
    glPushMatrix();
    glTranslated(x,y,0.0);
    glScalef(mirror, 1,1);

    //Body
    drawQuad_D(2,-3, 2,-4, 8,-4, 8,-3, r,g,b);
    //mirror
    drawQuad_D(3.5,-3, 8,-3, 7,-2,5,-2,0,0,0);
    //Frame
    glLineWidth(2.50f);
    glBegin(GL_LINE_LOOP);
    glColor3f(r,g,b);
    glVertex2f(6,-2);
    glVertex2f(6,-3);
    glVertex2f(8,-3);
    glVertex2f(7,-2);
    glVertex2f(5,-2);
    glVertex2f(3.5,-3);
    glVertex2f(6,-3);
    glEnd();

    //Light
    if (isNight_D)
    {
        glBegin(GL_TRIANGLES);
        glColor3f(1.0f, 1.0f, 0.5f);
        glVertex2f(2,-3.5);
        glVertex2f(0,-3);
        glVertex2f(0,-4);
        glEnd();
    }

    //Wheel 1
    drawRotatingWheel_D(3, -4, 0.5f, car2WheelAngle_D);
    //wheel 2
    drawRotatingWheel_D(7, -4, 0.5f, car2WheelAngle_D);

    glPopMatrix();
}

void Bus_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    //Roof
    glBegin(GL_POLYGON);
    glColor3f(1.0f, 1.0f, 0.0f);
    glVertex2f(22.5, -1.5);
    glVertex2f(32, -1.5);
    glVertex2f(32, -1.2);
    glVertex2f(32.4, -1);
    glVertex2f(22.5, -1);
    glEnd();

    //Body
    drawQuad_D(22, -1.5,22, -4,32, -4,32, -1.5,1.0f, 1.0f, 0.0f);
    //text color
    glColor3f(0.0f, 0.0f, 0.0f);
    renderText_D(25.0f, -3.50f, "School Bus");
    //FrontCurve
    SemiCircle_D(0.5, 22.5, -1.5, 1,1,0);

    //Back
    drawQuad_D(32.4, -1,32, -1.2,32, -4,32.4, -3.8,1.0f, 1.0f, 0.0f);

    glColor3f(0.5f, 0.5f, 0.5f);
    glLineWidth(1.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(32.4f, -1.0f);
    glVertex2f(32.0f, -1.2f);
    glVertex2f(32.0f, -4.0f);
    glVertex2f(32.4f, -3.8f);
    glEnd();


    if (isNight_D)
    {
        //Head Light
        glBegin(GL_TRIANGLES);
        glColor3f(1.0, 1.0, 0.5);
        glVertex2f(22,-3.5);
        glVertex2f(19,-3);
        glVertex2f(19,-4);
        glEnd();

        //Tail Light
        drawQuad_D(32.35, -3.5, 32.05, -3.65, 32.05, -3.85, 32.35, -3.7, 1.0f, 0.0f, 0.0f);
    }

    //wheel 1
    drawRotatingWheel_D(24, -4, 0.5f, busWheelAngle_D);
    //wheel 2
    drawRotatingWheel_D(30, -4, 0.5f, busWheelAngle_D);

    //Door
    drawQuad_D(23.2,-2, 22.6, -2, 22.6, -3.9, 23.2, -3.9,0.0f, 0.0f, 0.0f);

    //window
    drawQuad_D(24.4,-1.6,24.4,-2.6,25.4,-2.6,25.4,-1.6,0.0f, 0.0f, 0.0f);
    drawQuad_D(26.4,-1.6,26.4,-2.6,27.4,-2.6,27.4,-1.6,0.0f, 0.0f, 0.0f);
    drawQuad_D(28.4,-1.6,28.4,-2.6,29.4,-2.6,29.4,-1.6,0.0f, 0.0f, 0.0f);
    drawQuad_D(30.4,-1.6,30.4,-2.6,31.4,-2.6,31.4,-1.6,0.0f, 0.0f, 0.0f);

    glPopMatrix();
}

//Road Strip
void Strip_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);
    drawQuad_D(-35,-2.2,-35,-2.8,-30,-2.8,-30,-2.2, 1,1,1);
    glPopMatrix();
}

//Tree
void Tree_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    drawQuad_D(-38,-2.5,-38,-5,-37.5,-5,-37.5,-2.5, 0.36f, 0.25f, 0.20f);
    if(isNight_D)
    {
        Circle_D(1, -37.7, -1.6, 0.065f, 0.275f, 0.065f);
        Circle_D(0.7, -37, -2, 0.065f, 0.275f, 0.065f);
        Circle_D(0.7, -38.5, -2, 0.065f, 0.275f, 0.065f);
    }
    else if(isEvening_D)
    {
        Circle_D(1, -37.7, -1.6, 0.085f, 0.36f, 0.085f);
        Circle_D(0.7, -37, -2, 0.085f, 0.36f, 0.085f);
        Circle_D(0.7, -38.5, -2, 0.085f, 0.36f, 0.085f);
    }
    else
    {
        Circle_D(1,-37.7, -1.6, 0.13f, 0.55f, 0.13f);
        Circle_D(0.7,-37, -2, 0.13f, 0.55f, 0.13f);
        Circle_D(0.7,-38.5, -2, 0.13f, 0.55f, 0.13f);
    }


    glPopMatrix();
}

void BridgeLight_D(float x, float y, float r, float g, float  b)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    Circle_D(0.3,0,9.5,0.20,0.20,0.20);
    if(isNight_D)
        Circle_D(0.4,0,9.5,r,g,b);
    else if(isEvening_D)
        Circle_D(0.4,0,9.5,r,g,b);
    else
        Circle_D(0.2,0,9.5,0.8, 0.8, 0.8);

    glPopMatrix();
}

void Bridge_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    //Pillar
    drawQuad_D(-10.5,-5,-10.5,-8,-9.5,-8,-9.5,-5, 0.8, 0.8, 0.8);
    drawQuad_D(-11,-8,-11,-8.5,-9,-8.5,-9,-8, 0.36f, 0.25f, 0.20f);
    drawQuad_D(10.5,-5,10.5,-8,9.5,-8,9.5,-5, 0.8, 0.8, 0.8);
    drawQuad_D(11,-8,11,-8.5,9,-8.5,9,-8, 0.36f, 0.25f, 0.20f);

    //ROAD
    drawQuad_D(-40,0,-40,-5,40,-5,40,0, 0.2745f, 0.2784f, 0.2745f);
    Line_D(-40,0,40,0, 0,0,0);
    Line_D(-40,-5,40,-5, 0,0,0);

    //BridgeStructureUpper

    Line_D(-19,2.5,-19,0,0.20,0.20,0.20);
    Line_D(-18,3.5,-18,0,0.20,0.20,0.20);
    Line_D(-16,4.5,-16,0,0.20,0.20,0.20);
    Line_D(-14,4.5,-14,0,0.20,0.20,0.20);
    Line_D(-12,3.5,-12,0,0.20,0.20,0.20);
    Line_D(-11,2.5,-11,0,0.20,0.20,0.20);
    Bridge_Structure_D_Func(10,0,20,0);

    Line_D(11,2.5,11,0,0.20,0.20,0.20);
    Line_D(12,3.5,12,0,0.20,0.20,0.20);
    Line_D(14,4.5,14,0,0.20,0.20,0.20);
    Line_D(16,4.5,16,0,0.20,0.20,0.20);
    Line_D(18,3.5,18,0,0.20,0.20,0.20);
    Line_D(19,2.5,19,0,0.20,0.20,0.20);
    Bridge_Structure_D_Func(-10,0,-20,0);

    Line_D(-8,5.6,-8,0,0.20,0.20,0.20);
    Line_D(-6,7.6,-6,0,0.20,0.20,0.20);
    Line_D(-2,9.5,-2,0,0.20,0.20,0.20);
    Line_D(2,9.5,2,0,0.20,0.20,0.20);
    Line_D(6,7.6,6,0,0.20,0.20,0.20);
    Line_D(8,5.6,8,0,0.20,0.20,0.20);
    Bridge_Structure_D_Func(-10,0,10,0);

    //Road strip
    Strip_D(-7,0);
    Strip_D(0,0);
    Strip_D(7,0);
    Strip_D(14,0);
    Strip_D(21,0);
    Strip_D(28,0);
    Strip_D(35,0);
    Strip_D(42,0);
    Strip_D(49,0);
    Strip_D(56,0);
    Strip_D(63,0);
    Strip_D(70,0);

    //Car
    Car2_D(car2BPosX_D,2,0,1,0,-1);
    Car_D(carPosX_D,0,1,0,0.5,1,5);
    //Bus
    Car2_D(car2PosX_D,0,0,1,1,1);
    Bus_D(busPosX_D,0);

    //Tree on road left
    Tree_D(0,0);
    Tree_D(5,0);
    Tree_D(9,0);
    Tree_D(14,0);
    //Tree on road right
    Tree_D(62,0);
    Tree_D(69,0);
    Tree_D(76,0);

    //BridgeStructureLower
    Line_D(19,-5,19,-2.5,0.20,0.20,0.20);
    Line_D(18,-5,18,-1.3,0.20,0.20,0.20);
    Line_D(16,-5,16,-0.5,0.20,0.20,0.20);
    Line_D(14,-5,14,-0.5,0.20,0.20,0.20);
    Line_D(12,-5,12,-1.3,0.20,0.20,0.20);
    Line_D(11,-5,11,-2.5,0.20,0.20,0.20);
    Bridge_Structure_D_Func(10,-5,20,-5);

    Line_D(-19,-5,-19,-2.5,0.20,0.20,0.20);
    Line_D(-18,-5,-18,-1.3,0.20,0.20,0.20);
    Line_D(-16,-5,-16,-0.5,0.20,0.20,0.20);
    Line_D(-14,-5,-14,-0.5,0.20,0.20,0.20);
    Line_D(-12,-5,-12,-1.3,0.20,0.20,0.20);
    Line_D(-11,-5,-11,-2.5,0.20,0.20,0.20);
    Bridge_Structure_D_Func(-10,-5,-20,-5);

    Line_D(-8,0.5,-8,-5,0.20,0.20,0.20);
    Line_D(-6,2.5,-6,-5,0.20,0.20,0.20);
    Line_D(-2,4.5,-2,-5,0.20,0.20,0.20);
    Line_D(2,4.5,2,-5,0.20,0.20,0.20);
    Line_D(6,2.6,6,-5,0.20,0.20,0.20);
    Line_D(8,0.6,8,-5,0.20,0.20,0.20);
    Bridge_Structure_D_Func(-10,-5,10,-5);

    BridgeLight_D(0,0.45,1,0,0);
    BridgeLight_D(4,-0.32,1.0, 1.0, 0.5);
    BridgeLight_D(-4,-0.32,1.0, 1.0, 0.5);
    BridgeLight_D(-15,-4.5,0,0,1);
    BridgeLight_D(15,-4.5,0,0,1);

    /*BridgeLight_D(0,-4.5);
    BridgeLight_D(4,-5.3);
    BridgeLight_D(-4,-5.3);
    BridgeLight_D(-15,-9.5);
    BridgeLight_D(15,-9.5);*/

    glPopMatrix();
}
//********************LAKE**************************//
void Boat_D_1(float x, float y, float scale)
{
    glPushMatrix();
    glTranslated(x,y,0.0);
    glScalef(scale, scale, 1.0f);

    drawQuad_D(10,-10,10,-12,17,-12,17,-10, 0.2f, 0.2f, 0.2f);
    drawQuad_D(8,-12,8,-13,18,-13,18,-12,0.55f, 0.27f, 0.07f);
    glBegin(GL_TRIANGLES);
    glColor3f(0.55f, 0.27f, 0.07f);
    glVertex2f(6,-11);
    glVertex2f(8,-13);
    glVertex2f(8,-12);
    glEnd();
    glBegin(GL_TRIANGLES);
    glColor3f(0.55f, 0.27f, 0.07f);
    glVertex2f(20,-11);
    glVertex2f(18,-13);
    glVertex2f(18,-12);
    glEnd();

    // border
    glColor3f(0.0f, 0.0f, 0.0f);
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(6, -11);
    glVertex2f(8, -13);
    glVertex2f(18, -13);
    glVertex2f(20, -11);
    glVertex2f(18, -12);
    glVertex2f(8, -12);
    glEnd();

    glPopMatrix();
}
void Boat_D_2(float x, float y, float r, float g, float b)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    drawQuad_D(-22,-20,-20,-22,-14,-22,-10,-20, r,g,b);
    glColor3f(0.0f, 0.0f, 0.0f);
    renderText_D(-18.4f, -21.2f, "Speed Boat");
    drawQuad_D(-20,-19,-20,-20,-17,-20,-17,-19, 0.2f, 0.2f, 0.2f);
    drawQuad_D(-17.2,-18,-17,-18,-17,-20,-17.2,-20, 0.2f, 0.2f, 0.2f);

    glBegin(GL_TRIANGLES);
    glColor3f(0,0,0);
    glVertex2f(-17.2,-18);
    glVertex2f(-13,-20);
    glVertex2f(-11,-20);
    glEnd();

    // border
    glColor3f(0.0f, 0.0f, 0.0f);
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(-22, -20);
    glVertex2f(-20, -22);
    glVertex2f(-14, -22);
    glVertex2f(-10, -20);
    glEnd();

    glPopMatrix();
}

void Lake_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    if(isNight_D)
    {
        //Up
        drawQuad_D(-21,0,21,0,20,5,-20,5,0.1f, 0.1f, 0.3f);
        //Down
        drawQuad_D(-22,-5,-25,-25, 25,-25,22,-5, 0.1f, 0.1f, 0.3f);
    }
    else if(isEvening_D)
    {
        drawGradient_D(-25, 25, -25, 5,
                       0.62f, 0.40f, 0.28f,   // top
                       0.12f, 0.18f, 0.30f);  // bottom
    }
    else
    {
        //Up
        drawQuad_D(-21,0,21,0,20,5,-20,5,0.4f, 0.6f, 0.8f);
        //Down
        drawQuad_D(-22,-5,-25,-25, 25,-25,22,-5, 0.4f, 0.6f, 0.8f);
    }

    //Call boat
    Boat_D_1(0,1, 1);
    Boat_D_1(boat1_PosX_D,8, 0.5);
    //Call speedboat
    Boat_D_2(0,0, 0.6f, 0.6f, 0.65f);
    Boat_D_2(boat2_PosX_D, 5,1,1,1);

    glPopMatrix();
}
//*******************BUILDING******************//
void building_1Window_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    //Body
    drawQuad_D(31,-13,31,-15,32,-15,32,-13, 0,0,0);
    //white border
    Line_D(31, -13, 31, -15, 1.0f, 1.0f, 1.0f);
    Line_D(31, -15, 32, -15, 1.0f, 1.0f, 1.0f);
    Line_D(32, -15, 32, -13, 1.0f, 1.0f, 1.0f);
    Line_D(32, -13, 31, -13, 1.0f, 1.0f, 1.0f);
    glPopMatrix();
}

void Building1_D(float x, float y, float scale,float r, float g, float b)
{
    glPushMatrix();
    glTranslated(x,y,0.0);
    glScalef(scale, scale, 1.0f);

    //Roof
    glBegin(GL_TRIANGLES);
    glColor3f(0,0,0);
    glVertex2f(35,-10);
    glVertex2f(30,-12);
    glVertex2f(40,-12);
    glEnd();
    //Body
    drawQuad_D(30,-12,30,-24.5,40,-24.5,40,-12, r,g,b);

    //windows
    building_1Window_D(0,0);
    building_1Window_D(2,0);
    building_1Window_D(5,0);
    building_1Window_D(7,0);

    building_1Window_D(0,-3);
    building_1Window_D(2,-3);
    building_1Window_D(5,-3);
    building_1Window_D(7,-3);

    building_1Window_D(0,-6);
    building_1Window_D(2,-6);
    building_1Window_D(5,-6);
    building_1Window_D(7,-6);

    building_1Window_D(0,-9);
    building_1Window_D(2,-9);
    building_1Window_D(5,-9);
    building_1Window_D(7,-9);

    //Ground
    drawQuad_D(29.5,-24.5,29.5,-25,40.5,-25,40.5,-24.5, 0,0,0);

    glPopMatrix();
}

void building_2Window_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    drawQuad_D(33,-6,33,-8,35,-8,35,-6,0.2,0.2,0.2);
    glColor3f(0.0f, 0.0f, 1.0f);
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(33, -6);
    glVertex2f(33, -8);
    glVertex2f(35, -8);
    glVertex2f(35, -6);
    glEnd();

    //divide
    Line_D(34,-6,34,-8,1,1,1);
    Line_D(33,-7,35,-7,1,1,1);
    glPopMatrix();
}

void Building2_D(float x, float y, float scale, float r, float g, float b)
{
    glPushMatrix();
    glTranslated(x,y,0.0);
    glScalef(scale, scale, 1.0f);

    //Upper roof
    drawQuad_D(34.5,-3.5,34.5,-4,37.5,-4,37.5,-3.5,0,0,0);
    //Roof
    drawQuad_D(40,-4,32,-4,32,-5,40,-5,0,0,0);

    //Body
    drawQuad_D(32,-5,32,-14,40,-14,40,-5,r,g,b);
    glColor3f(0.0f, .0f, 0.8f); // white border
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(32, -5);
    glVertex2f(32, -14);
    glVertex2f(40, -14);
    glVertex2f(40, -5);
    glEnd();

    //Divide
    Line_D(36,-5,36,-14,0,0,1);

    //windows
    building_2Window_D(0,0);
    building_2Window_D(4,0);

    building_2Window_D(0,-2.5);
    building_2Window_D(4,-2.5);

    building_2Window_D(0,-5);
    building_2Window_D(4,-5);

    glPopMatrix();
}
void building_3Window_D(float x, float y)
{
    glPushMatrix();
    glTranslated(x,y,0.0);

    // Window body
    drawQuad_D(29.5,-9,29.5,-11,30.5,-11,30.5,-9, 0.0f, 0.0f, 0.0f);
    // Border (blue)
    glColor3f(0.0f, 0.0f, 1.0f);
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(29.5, -9);
    glVertex2f(29.5, -11);
    glVertex2f(30.5, -11);
    glVertex2f(30.5, -9);
    glEnd();
    glPopMatrix();
}
void Building3_D(float x, float y, float scale)
{
    glPushMatrix();
    glTranslated(x,y,0.0);
    glScalef(scale, scale, 1.0f);

    //roof
    drawQuad_D(25.8, -6,25.8, -8,34.2, -8,34.2, -6,0.6f, 0.3f, 0.0f);
    glColor3f(0.0f, 0.0f, 0.0f);
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(25.8, -6);
    glVertex2f(25.8, -8);
    glVertex2f(34.2, -8);
    glVertex2f(34.2, -6);
    glEnd();

    //body
    drawQuad_D(26,-8,26,-22,34,-22,34,-8,0.831f, 0.714f, 0.518f);
    glColor3f(0.0f, 0.0f, 0.0f);
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(26, -8);
    glVertex2f(26, -22);
    glVertex2f(34, -22);
    glVertex2f(34, -8);
    glEnd();

    //middle
    drawQuad_D(29,-8,29,-22,31,-22,31,-8,1,1,1);
    // Border (black)
    glColor3f(0.0f, 0.0f, 0.0f);
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(29, -8);
    glVertex2f(29, -22);
    glVertex2f(31, -22);
    glVertex2f(31, -8);
    glEnd();

    //Stair Window
    building_3Window_D(0,0);
    building_3Window_D(0,-3);
    building_3Window_D(0,-3);
    building_3Window_D(0,-6);
    building_3Window_D(0,-9);

    //Floor divider
    Line_D(26,-10,29,-10,0,0,0);
    Line_D(26,-12,29,-12,0,0,0);
    Line_D(26,-14,29,-14,0,0,0);
    Line_D(26,-16,29,-16,0,0,0);
    Line_D(26,-18,29,-18,0,0,0);
    Line_D(26,-20,29,-20,0,0,0);

    Line_D(34, -10, 31, -10, 0, 0, 0);
    Line_D(34, -12, 31, -12, 0, 0, 0);
    Line_D(34, -14, 31, -14, 0, 0, 0);
    Line_D(34, -16, 31, -16, 0, 0, 0);
    Line_D(34, -18, 31, -18, 0, 0, 0);
    Line_D(34, -20, 31, -20, 0, 0, 0);

    glPopMatrix();
}

void Building_D()
{
    //Build area ground
    Line_D(-19.95,5,-20.95,0,0,0,0);
    Line_D(19.95,5,20.95,0,0,0,0);
    Line_D(21.93,-5,24.5,-25.5,0,0,0);
    Line_D(-22,-5,-25,-25,0,0,0);

    drawQuad_D(22,-5,24.5,-25,40,-25,40,-5,0.486f, 0.435f, 0.420f);
    drawQuad_D(20,5,21,0,40,0,40,5,0.486f, 0.435f, 0.420f);
    drawQuad_D(-20,5,-21,0,-40,0,-40,5,0.486f, 0.435f, 0.420f);

    //Lower right
    Building2_D(-4,2,1.1, 0.992f, 0.914f, 0.894f);
    Building3_D(-1.75,0,1);
    Building1_D(-1,0,1, 0.259, 0.788, 0.369);

    //Upper right
    Building1_D(3,17,0.6, 0.690, 0.482, 0.910);
    Building2_D(-9,18,1.2, 1.000, 0.251, 0.251);
    Tree_D(62,5);
    Tree_D(69,5);
    Tree_D(76,5);

    //upper left
    Building3_D(-38,14,0.5);
    Building2_D(-53.5,11.5,0.7,0.8, 0.8, 0.8);
    Building1_D(-60,18,0.7,0.404, 0.612, 0.922);
    Tree_D(0,5);
    Tree_D(7,5);
    Tree_D(14,5);

}
//PARK***************
void Road_Park_D()
{
    //Grass
    drawQuad_D(-40,-5,-40,-25,-25,-25,-22,-5, 0.486f, 0.435f, 0.420f);
    //Road
    drawQuad_D(-32,-25,-30,-25,-30,-5,-32,-5, 0.2,0.2,0.2);
    drawQuad_D(-40,-12,-40,-14,-23.3,-14,-23,-12,0.2,0.2,0.2);
    drawQuad_D(-40,-22,-40,-24,-24.8,-24,-24.5,-22,0.2,0.2,0.2);
}

void Park_D()
{
    Road_Park_D();
    //Block A
    Tree_D(2,-4);
    Tree_D(4,-7);
    Tree_D(-1.5,-7);

    //Block B
    drawQuad_D(-28,-8,-29,-9,-24,-9,-23,-8,0.627,0.322,0.176);

    Line_D(-29,-9,-29,-10,0,0,0);
    Line_D(-28,-9.5,-28,-9,0,0,0);
    Line_D(-24,-9,-24,-10,0,0,0);
    Line_D(-23,-8,-23,-9.5,0,0,0);
    glBegin(GL_LINE_LOOP);
    glColor3f(0,0,0);
    glVertex2f(-28,-8);
    glVertex2f(-29,-9);
    glVertex2f(-24,-9);
    glVertex2f(-23,-8);
    glVertex2f(-28,-8);
    glEnd();

    //Block C
    drawQuad_D(-39,-17,-38,-18,-33,-18,-34,-17,0.627,0.322,0.176);
    Line_D(-39,-17,-39,-18.5,0,0,0);
    Line_D(-38,-18,-38,-19,0,0,0);
    Line_D(-34,-18,-34,-18.5,0,0,0);
    Line_D(-33,-18,-33,-19,0,0,0);
    glBegin(GL_LINE_LOOP);
    glColor3f(0,0,0);
    glVertex2f(-39,-17);
    glVertex2f(-38,-18);
    glVertex2f(-33,-18);
    glVertex2f(-34,-17);
    glVertex2f(-39,-17);
    glEnd();

    Tree_D(5,-19);
    Tree_D(0,-19);
    Tree_D(2,-9);

    //Block D
    Tree_D(9,-9);
    Tree_D(11,-17);
    Tree_D(13,-9);
}

void Rain_Update_D()
{
    if (raining_D)
    {
        for (int i = 0; i < totalDrops_D; ++i)
        {
            dropY_D[i] -= 0.3f;  // move down
            if (dropY_D[i] <= -25.0f)    // reset
            {
                dropX_D[i] = randX_D();
                dropY_D[i] = 20.0f;
            }
        }
        for (int i = 0; i < 2; ++i) addDrop_D();  // keep adding new drops
    }
}
void Bird_Upadate_D()
{
    // Birds Animation
    float speed = 0.08f; // same X speed

    // Bird 1
    birdX1_D += speed;
    birdWingY1_D += 0.3f;
    if (birdWingY1_D > 1) birdWingY1_D = -1;
    if (birdX1_D > 45) birdX1_D = -45;
    // Bird 2
    birdX2_D += speed;
    birdWingY2_D += 0.3f;
    if (birdWingY2_D > 1) birdWingY2_D = -1;
    if (birdX2_D > 45) birdX2_D = -45;
    // Bird 3
    birdX3_D += speed;
    birdWingY3_D += 0.3f;
    if (birdWingY3_D > 1) birdWingY3_D = -1;
    if (birdX3_D > 45) birdX3_D = -45;

}
void Cloud_Update_D()
{
    // right to left
    cloud_D_1PosX_D += 0.04f;
    if (cloud_D_1PosX_D >125) cloud_D_1PosX_D = -10;   // Reset

    // right to left
    cloud_D_2PosX_D -= 0.08f;
    if (cloud_D_2PosX_D < -55) cloud_D_2PosX_D = 125;   // Reset
}
void Boat_update_D()
{
    boat1_PosX_D += boat1_Speed_D;
    if (boat1_PosX_D > 8 || boat1_PosX_D < -22)
    {
        boat1_Speed_D = -boat1_Speed_D;  // reverse direction
    }

    boat2_PosX_D += boat2_Speed_D;
    if (boat2_PosX_D > 28 || boat2_PosX_D < 0)
    {
        boat2_Speed_D = -boat2_Speed_D;  // reverse direction
    }
}
void Vehicle_Update_D()
{
    // left to right
    carPosX_D += 0.08f*speedMultiplier_D;
    if (carPosX_D > 50) carPosX_D = -40;

    // right to left
    car2PosX_D -= 0.17f*speedMultiplier_D;
    if (car2PosX_D < -50) car2PosX_D = 40;

    // right to left
    car2BPosX_D += 0.17f*speedMultiplier_D;
    if (car2BPosX_D >50) car2BPosX_D = -40;

    busPosX_D -= 0.08f*speedMultiplier_D;
    if (busPosX_D < -75) busPosX_D = 20;   // Reset

    //clockwise
    busWheelAngle_D += 5.0f*speedMultiplier_D;
    if (busWheelAngle_D <= -360.0f) busWheelAngle_D = 0.0f;
    //Anticlockwise Car1
    carWheelAngle_D -= 5.0f*speedMultiplier_D;
    if (carWheelAngle_D <= -360.0f) carWheelAngle_D = 0.0f;
    //Anticlockwise Car1
    car2WheelAngle_D += 7.0f*speedMultiplier_D;
    if (car2WheelAngle_D <= -360.0f) car2WheelAngle_D = 0.0f;
}
void update_D(int value)
{
    if (paused_D)
    {
        glutTimerFunc(16, update_D, 0); // call timer do nothing
        return;
    }
    Rain_Update_D();
    Bird_Upadate_D();
    Cloud_Update_D();
    Boat_update_D();
    Vehicle_Update_D();

    glutPostRedisplay();
    glutTimerFunc(16, update_D, 0);
}

void Scene_D()
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-40, 40, -25, 20);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    Sky_D(0,0);
    birdDisplay_D();
    Bridge_D(0,0);
    Lake_D(0,0);
    Bridge_D(0,0);
    Park_D();
    Building_D();

    if (raining_D && totalDrops_D > 0) drawRaindrops_D();
}
//For all------------------------------------------------------------------
void display()
{
    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    if (currentScene == 1)
    {
        UttaraDiaBari();
    }
    else if (currentScene == 2)
    {
        Scene_B();   // Expressway
    }
    else if (currentScene == 3)
    {
        Scene_c();   // Hatirjheel
    }
    else if (currentScene == 4)
    {
        Scene_D();   // Hatirjheel
    }

    glutSwapBuffers();

}
//MUST use
void init()
{
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    srand(static_cast<unsigned int>(time(0)));

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    glEnable(GL_LINE_SMOOTH);
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);

    glEnable(GL_POLYGON_SMOOTH);
    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
}

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);

    int windowWidth = 1350;
    int windowHeight = 700;

    // Get screen width and height
    int screenWidth  = glutGet(GLUT_SCREEN_WIDTH);
    int screenHeight = glutGet(GLUT_SCREEN_HEIGHT);

    int x = (screenWidth  - windowWidth) / 2;
    int y = (screenHeight - windowHeight) / 2;

    glutInitWindowSize(windowWidth, windowHeight);
    glutInitWindowPosition(x, y);
    glutCreateWindow("Uttara Diabari");

    init();

    //Scene A
    glutTimerFunc(16, CloudMovement, 0);
    glutTimerFunc(16, car_update1A, 0);
    glutTimerFunc(16, car_rotate1A, 0);
    glutTimerFunc(16, car_update2A, 0);
    glutTimerFunc(16, car_rotate2A, 0);
    glutTimerFunc(16, car_update3A, 0);
    glutTimerFunc(16, car_rotate3A, 0);
    glutTimerFunc(16, car_update4A, 0);
    glutTimerFunc(16, car_rotate4A, 0);
    glutTimerFunc(16, boat_update1A, 0);
    glutTimerFunc(16, boat_update3A, 0);
    glutTimerFunc(0, RainUpdate, 0);
    glutTimerFunc(0, plane_update, 0);
    glutTimerFunc(16, Bird_update, 0);
    //Scene B
    glutTimerFunc(0, update_B, 0);
    glutTimerFunc(0, update, 0);
    //Scene D
    glutTimerFunc(0, update_D, 0);

    glutKeyboardFunc(keyboard_D);
    glutMouseFunc(mouseHandler_D);
    glutDisplayFunc(display);

    glutMainLoop();

    return 0;
}
